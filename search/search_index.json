{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to AsFem This is A S imple F inite E lement M ethod program for the phase-field modeling and multiphysics simulation, which is short for AsFem . For efficient computation and simulation, the package is written in C++ and relies heavily on the PETSc library. It is primarily developed for solid mechanics and phase-field modeling. spinodal-decomposition double-notch failure","title":"Home"},{"location":"#welcome-to-asfem","text":"This is A S imple F inite E lement M ethod program for the phase-field modeling and multiphysics simulation, which is short for AsFem . For efficient computation and simulation, the package is written in C++ and relies heavily on the PETSc library. It is primarily developed for solid mechanics and phase-field modeling. spinodal-decomposition double-notch failure","title":"Welcome to AsFem"},{"location":"about/","text":"What is it? This is A S imple F inite E lement M ethod program for the phase-field modeling and multiphysics simulation, which is short for AsFem . What can it do ? [x] Solid Mechanics [x] CahnHilliard diffusion [x] Phase-field fracture model [x] Linear elastic materials How to use it ? The documentation is under construction at present. If you have any questions, just email me: Yang or for Chinese users, we can also discuss more about it in the QQ group:: 879908352","title":"About"},{"location":"about/#what-is-it","text":"This is A S imple F inite E lement M ethod program for the phase-field modeling and multiphysics simulation, which is short for AsFem .","title":"What is it?"},{"location":"about/#what-can-it-do","text":"[x] Solid Mechanics [x] CahnHilliard diffusion [x] Phase-field fracture model [x] Linear elastic materials","title":"What can it do ?"},{"location":"about/#how-to-use-it","text":"The documentation is under construction at present. If you have any questions, just email me: Yang or for Chinese users, we can also discuss more about it in the QQ group:: 879908352","title":"How to use it ?"},{"location":"install/","text":"System requirement Linux Windows (only works for Cygwin+VisualStudio 2020 or newer) MacOX (it should work, but we haven't tested it yet!) Basic components Before we start the installation, some components are required, for example: gcc g++ gfortran cmake git python3 In the following installation, please do not use sudo or root !!! It's only supposed to be used for system installation like sudo apt install , sudo zypper install , sudo yum install , and so on . It is highly recommended to install the openmpi and PETSc packages from the source code! Install gcc One can follow the steps list below to install a modern GCC compiler if one don't already have one. Otherwise, please go straight to the MPI setup . Before you start, you'll need a GCC (the old one) compiler to compile another GCC, therefore if your system doesn't have one, please run(for Ubuntu) : sudo apt install gcc g++ gfortran cmake git python3 build-essential For ubuntu 22.04, apt install will bring you the GCC11.2.0 package which is new and good enough for our installation, so you can skip the GCC installation part list below. Anyway, you can also install a newer version, i.e., GCC12.1.0 or even newer. The installation itself is not limited to Ubuntu system, for other linux distributions, one need to change the command to the consistent one. For instance, sudo zypper , sudo yum , sudo dnf ... : To begin, one should download and unzip the gcc source code: curl -L -O http://mirrors.concertpass.com/gcc/releases/gcc-11.3.0/gcc-11.3.0.tar.gz tar -xf gcc-11.3.0.tar.gz or directly go to the official website gcc . Next, we'll need to download the GCC pre-request as follows: cd gcc-11.3.0 ./contrib/download_prerequisites we can then configure, build and install GCC: ./configure --prefix=**your-gcc-install-path** \\ --disable-multilib \\ --enable-languages=c,c++,fortran,jit \\ --enable-checking=release \\ --enable-host-shared \\ --with-pic where **your-gcc-install-path** represents the installation path on your own computer . Then one can execute: make -j4 and make install In the following installation, we must configure our bash environment for using our modern GCC(if you have installed your gcc via sudo apt or sudo yum or sudo zypper or whatever sudo x , please skip this step, because your GCC is ready!): export gcc=your-gcc-instal-path export PATH=$gcc/bin:$PATH export LD_LIBRARY_PATH=$gcc/lib64:$gcc/lib:$gcc/lib/gcc/x86_64-pc-linux-gnu/11.3.0:$gcc/libexec/gcc/x86_64-pc-linux-gnu/11.3.0:$LD_LIBRARY_PATH you can either paste the above settings to your ~/.bashrc file or put it into a new file, i.e., ~/.asfem-profile . Install mpi The MPI compiler is required to use the PETSc package for parallelization. Please skip this stage if your machine already has the MPI compiler installed . curl -L -O https://download.open-mpi.org/release/open-mpi/v4.1/openmpi-4.1.4.tar.gz Alternatively, you can get the source code from openmpi . Then you can config, build and install your openmpi ( if you installed the GCC by compiling the source code rather than using sudo apt install , then please do source ~/.asfem-profile to set up your environment before running the following step ): tar -xf openmpi-4.1.4.tar.gz cd openmpi-4.1.4 ./configure --prefix=*your-path-to-opemmpi* make -j8 make install again, *your-path-to-opemmpi* should be your own installation path. After that, you should put the related settings into your bash environment as follows: export MPI_DIR=your-path-to-openmpi export PATH=$PATH:$MPI_DIR/bin # please comment out the following four lines until the PETSc has installed !!! #export CC=mpicc #export CXX=mpicxx #export FC=mpif90 #export F90=mpif90 export OMP_NUM_THREADS=1 export C_INCLUDE_PATH=$MPI_DIR/include:$C_INCLUDE_PATH export CPLUS_INCLUDE_PATH=$MPI_DIR/include:$CPLUS_INCLUDE_PATH export FPATH=$MPI_DIR/include:$FPATH export MANPATH=$MPI_DIR/share/man:$MANPATH export LD_LIBRARY_PATH=$MPI_DIR/lib:$LD_LIBRARY_PATH Now one can execute the source ~/.asfem-profile command, and then do: mpirun -np 4 echo \"Hi\" you should see 4x\"Hi\" in your terminal. Install PETSc Before we begin, make sure your GCC and MPI compilers are up to date (by doing source ~/.asfem-profile ) , ( if both of your GCC and MPI are installed from sudo , then the newly opened terminal will find the gcc/mpicc compiler, which means you do not need to execute source ~/.bashrc or source ~/.asfem-profile ! ): source ~/.asfem-profile gcc --version mpicxx --version Plase keep in mind, these four lines must be uncommented in your ~/.asfem-profile #export CC=mpicc #export CXX=mpicxx #export FC=mpif90 #export F90=mpif90 We will tell PETSc the path to the openmpi, then it will find the correct compiler. The PETSc package can be downloaded via (you can change the version number to whatever you like, for example, petsc-3.17.2.tar.gz , petsc-3.16.3.tar.gz ): curl -L -O https://ftp.mcs.anl.gov/pub/petsc/release-snapshots/petsc-lite-3.17.2.tar.gz or you can download it from the PETSc website . For the configuration, one can use: ./configure \\ --prefix=***your-PETSc-install-path*** \\ --with-debugging=0 \\ --with-ssl=0 \\ --with-pic=1 \\ --with-openmp=0 \\ --with-mpi-dir=***your-MPI-install-path*** \\ --with-shared-libraries=1 \\ --with-cxx-dialect=C++14 \\ --with-fortran-bindings=1 \\ --with-sowing=0 \\ --download-fblaslapack=1 \\ COPTFLAGS='-fPIC -O3 -march=native ' \\ CXXOPTFLAGS='-fPIC -O3 -march=native ' \\ FOPTFLAGS='-fPIC -O3 -march=native ' \\ PETSC_DIR=`pwd` once again, ***your-PETSc-install-path*** should be your PETSc installation path, and ***your-MPI-install-path*** is the path of your MPI. Then, by running the make xxxx -j8 and make xxxx install command, one can finish the installation. Here xxx represents the command line which is shown by PETSc in your terminal! If -march=native flag doesn't work on your system, then please remove it. Afterwards, put the related settings into your ~/.asfem-profile (now, you need to uncomment export CC=xxx ) as follows: export gcc=***your-path-to-gcc-install-path*** export PETSC_DIR=***your-path-to-petsc-install-dir*** export MPI_DIR=***your-path-to-openmpi*** export PATH=$gcc/bin:$PATH export PATH=$MPI_DIR/bin:$PATH export LD_LIBRARY_PATH=$gcc/lib64:$gcc/lib:$gcc/lib/gcc/x86_64-pc-linux-gnu/11.3.0:$gcc/libexec/gcc/x86_64-pc-linux-gnu/11.3.0:$LD_LIBRARY_PATH export CC=mpicc export CXX=mpicxx export FC=mpif90 export F90=mpif90 export C_INCLUDE_PATH=$MPI_DIR/include:$C_INCLUDE_PATH export CPLUS_INCLUDE_PATH=$MPI_DIR/include:$CPLUS_INCLUDE_PATH export FPATH=$MPI_DIR/include:$FPATH export MANPATH=$MPI_DIR/share/man:$MANPATH export LD_LIBRARY_PATH=$MPI_DIR/lib:$LD_LIBRARY_PATH export OMP_NUM_THREADS=1 Once again, if you installed your GCC and openmpi from sudo , then you only need: export PETSC_DIR=***your-path-to-petsc-install-dir*** export MPI_DIR=***your-path-to-openmpi*** export CC=mpicc export CXX=mpicxx export FC=mpif90 export F90=mpif90 export OMP_NUM_THREADS=1 Install AsFem Download AsFem: git clone https://github.com/M3Group/AsFem.git if one wants to have a try for the devel version ( unstable ), one can use: git clone -b devel https://github.com/M3Group/AsFem.git then execute source ~/.asfem-profile , and then we can get the makefile via: cmake CMakeLists.txt -DCMAKE_BUILD_TYPE=Release afterwards, we can make the asfem by executing: make -j4 the executable file asfem can be found in the AsFem/bin folder. It is also highly recommended to put asfem into your PATH as follows: export asfem=**your-path-to-asfem** export PATH=$PATH:$asfem/bin then one can easily run the AsFem job from the terminal as follows: asfem -i yourjob.i mpirun -np 16 asfem -i yourjob.i That's all, enjoy!","title":"Installation"},{"location":"install/#system-requirement","text":"Linux Windows (only works for Cygwin+VisualStudio 2020 or newer) MacOX (it should work, but we haven't tested it yet!)","title":"System requirement"},{"location":"install/#basic-components","text":"Before we start the installation, some components are required, for example: gcc g++ gfortran cmake git python3 In the following installation, please do not use sudo or root !!! It's only supposed to be used for system installation like sudo apt install , sudo zypper install , sudo yum install , and so on . It is highly recommended to install the openmpi and PETSc packages from the source code!","title":"Basic components"},{"location":"install/#install-gcc","text":"One can follow the steps list below to install a modern GCC compiler if one don't already have one. Otherwise, please go straight to the MPI setup . Before you start, you'll need a GCC (the old one) compiler to compile another GCC, therefore if your system doesn't have one, please run(for Ubuntu) : sudo apt install gcc g++ gfortran cmake git python3 build-essential For ubuntu 22.04, apt install will bring you the GCC11.2.0 package which is new and good enough for our installation, so you can skip the GCC installation part list below. Anyway, you can also install a newer version, i.e., GCC12.1.0 or even newer. The installation itself is not limited to Ubuntu system, for other linux distributions, one need to change the command to the consistent one. For instance, sudo zypper , sudo yum , sudo dnf ... : To begin, one should download and unzip the gcc source code: curl -L -O http://mirrors.concertpass.com/gcc/releases/gcc-11.3.0/gcc-11.3.0.tar.gz tar -xf gcc-11.3.0.tar.gz or directly go to the official website gcc . Next, we'll need to download the GCC pre-request as follows: cd gcc-11.3.0 ./contrib/download_prerequisites we can then configure, build and install GCC: ./configure --prefix=**your-gcc-install-path** \\ --disable-multilib \\ --enable-languages=c,c++,fortran,jit \\ --enable-checking=release \\ --enable-host-shared \\ --with-pic where **your-gcc-install-path** represents the installation path on your own computer . Then one can execute: make -j4 and make install In the following installation, we must configure our bash environment for using our modern GCC(if you have installed your gcc via sudo apt or sudo yum or sudo zypper or whatever sudo x , please skip this step, because your GCC is ready!): export gcc=your-gcc-instal-path export PATH=$gcc/bin:$PATH export LD_LIBRARY_PATH=$gcc/lib64:$gcc/lib:$gcc/lib/gcc/x86_64-pc-linux-gnu/11.3.0:$gcc/libexec/gcc/x86_64-pc-linux-gnu/11.3.0:$LD_LIBRARY_PATH you can either paste the above settings to your ~/.bashrc file or put it into a new file, i.e., ~/.asfem-profile .","title":"Install gcc"},{"location":"install/#install-mpi","text":"The MPI compiler is required to use the PETSc package for parallelization. Please skip this stage if your machine already has the MPI compiler installed . curl -L -O https://download.open-mpi.org/release/open-mpi/v4.1/openmpi-4.1.4.tar.gz Alternatively, you can get the source code from openmpi . Then you can config, build and install your openmpi ( if you installed the GCC by compiling the source code rather than using sudo apt install , then please do source ~/.asfem-profile to set up your environment before running the following step ): tar -xf openmpi-4.1.4.tar.gz cd openmpi-4.1.4 ./configure --prefix=*your-path-to-opemmpi* make -j8 make install again, *your-path-to-opemmpi* should be your own installation path. After that, you should put the related settings into your bash environment as follows: export MPI_DIR=your-path-to-openmpi export PATH=$PATH:$MPI_DIR/bin # please comment out the following four lines until the PETSc has installed !!! #export CC=mpicc #export CXX=mpicxx #export FC=mpif90 #export F90=mpif90 export OMP_NUM_THREADS=1 export C_INCLUDE_PATH=$MPI_DIR/include:$C_INCLUDE_PATH export CPLUS_INCLUDE_PATH=$MPI_DIR/include:$CPLUS_INCLUDE_PATH export FPATH=$MPI_DIR/include:$FPATH export MANPATH=$MPI_DIR/share/man:$MANPATH export LD_LIBRARY_PATH=$MPI_DIR/lib:$LD_LIBRARY_PATH Now one can execute the source ~/.asfem-profile command, and then do: mpirun -np 4 echo \"Hi\" you should see 4x\"Hi\" in your terminal.","title":"Install mpi"},{"location":"install/#install-petsc","text":"Before we begin, make sure your GCC and MPI compilers are up to date (by doing source ~/.asfem-profile ) , ( if both of your GCC and MPI are installed from sudo , then the newly opened terminal will find the gcc/mpicc compiler, which means you do not need to execute source ~/.bashrc or source ~/.asfem-profile ! ): source ~/.asfem-profile gcc --version mpicxx --version Plase keep in mind, these four lines must be uncommented in your ~/.asfem-profile #export CC=mpicc #export CXX=mpicxx #export FC=mpif90 #export F90=mpif90 We will tell PETSc the path to the openmpi, then it will find the correct compiler. The PETSc package can be downloaded via (you can change the version number to whatever you like, for example, petsc-3.17.2.tar.gz , petsc-3.16.3.tar.gz ): curl -L -O https://ftp.mcs.anl.gov/pub/petsc/release-snapshots/petsc-lite-3.17.2.tar.gz or you can download it from the PETSc website . For the configuration, one can use: ./configure \\ --prefix=***your-PETSc-install-path*** \\ --with-debugging=0 \\ --with-ssl=0 \\ --with-pic=1 \\ --with-openmp=0 \\ --with-mpi-dir=***your-MPI-install-path*** \\ --with-shared-libraries=1 \\ --with-cxx-dialect=C++14 \\ --with-fortran-bindings=1 \\ --with-sowing=0 \\ --download-fblaslapack=1 \\ COPTFLAGS='-fPIC -O3 -march=native ' \\ CXXOPTFLAGS='-fPIC -O3 -march=native ' \\ FOPTFLAGS='-fPIC -O3 -march=native ' \\ PETSC_DIR=`pwd` once again, ***your-PETSc-install-path*** should be your PETSc installation path, and ***your-MPI-install-path*** is the path of your MPI. Then, by running the make xxxx -j8 and make xxxx install command, one can finish the installation. Here xxx represents the command line which is shown by PETSc in your terminal! If -march=native flag doesn't work on your system, then please remove it. Afterwards, put the related settings into your ~/.asfem-profile (now, you need to uncomment export CC=xxx ) as follows: export gcc=***your-path-to-gcc-install-path*** export PETSC_DIR=***your-path-to-petsc-install-dir*** export MPI_DIR=***your-path-to-openmpi*** export PATH=$gcc/bin:$PATH export PATH=$MPI_DIR/bin:$PATH export LD_LIBRARY_PATH=$gcc/lib64:$gcc/lib:$gcc/lib/gcc/x86_64-pc-linux-gnu/11.3.0:$gcc/libexec/gcc/x86_64-pc-linux-gnu/11.3.0:$LD_LIBRARY_PATH export CC=mpicc export CXX=mpicxx export FC=mpif90 export F90=mpif90 export C_INCLUDE_PATH=$MPI_DIR/include:$C_INCLUDE_PATH export CPLUS_INCLUDE_PATH=$MPI_DIR/include:$CPLUS_INCLUDE_PATH export FPATH=$MPI_DIR/include:$FPATH export MANPATH=$MPI_DIR/share/man:$MANPATH export LD_LIBRARY_PATH=$MPI_DIR/lib:$LD_LIBRARY_PATH export OMP_NUM_THREADS=1 Once again, if you installed your GCC and openmpi from sudo , then you only need: export PETSC_DIR=***your-path-to-petsc-install-dir*** export MPI_DIR=***your-path-to-openmpi*** export CC=mpicc export CXX=mpicxx export FC=mpif90 export F90=mpif90 export OMP_NUM_THREADS=1","title":"Install PETSc"},{"location":"install/#install-asfem","text":"Download AsFem: git clone https://github.com/M3Group/AsFem.git if one wants to have a try for the devel version ( unstable ), one can use: git clone -b devel https://github.com/M3Group/AsFem.git then execute source ~/.asfem-profile , and then we can get the makefile via: cmake CMakeLists.txt -DCMAKE_BUILD_TYPE=Release afterwards, we can make the asfem by executing: make -j4 the executable file asfem can be found in the AsFem/bin folder. It is also highly recommended to put asfem into your PATH as follows: export asfem=**your-path-to-asfem** export PATH=$PATH:$asfem/bin then one can easily run the AsFem job from the terminal as follows: asfem -i yourjob.i mpirun -np 16 asfem -i yourjob.i That's all, enjoy!","title":"Install AsFem"},{"location":"release/","text":"All the release can be download from here AsFem-Release \ud83c\udf1f Version v0.5 is released! \ud83d\udca5 Breaking Changes Name-based material properties accessing Further simplify the user element coding, nodal loop is required anymore Citation is available in Zenodo \u2b50 Features Material properties projection Postprocesses for elemental and side DoFs/Materials integral \ud83d\udc1e Bug Fixes Fix setting errors in Gmsh2IO and Gmsh4IO \ud83d\udee0 Improvements Error detector for the boundary condition system","title":"Release"},{"location":"release/#version-v05-is-released","text":"","title":"\ud83c\udf1f Version v0.5 is released!"},{"location":"release/#breaking-changes","text":"Name-based material properties accessing Further simplify the user element coding, nodal loop is required anymore Citation is available in Zenodo","title":"\ud83d\udca5 Breaking Changes"},{"location":"release/#features","text":"Material properties projection Postprocesses for elemental and side DoFs/Materials integral","title":"\u2b50 Features"},{"location":"release/#bug-fixes","text":"Fix setting errors in Gmsh2IO and Gmsh4IO","title":"\ud83d\udc1e Bug Fixes"},{"location":"release/#improvements","text":"Error detector for the boundary condition system","title":"\ud83d\udee0 Improvements"},{"location":"Document/block-bcs/","tags":["blocks","input file","bcs"],"text":"[bcs] block The block [bcs] is used to apply the different types of boundary conditions, i.e. Dirichlet boundary condition, Neumann boundary condition, Robin boundary condition, as well as User-Defined-BC ( UBC ). This block's layout looks as follows: [bcs] [mybc1] type=dirichlet dofs=dof1 boundary=left right ... value=bcvalue [end] [end] options The type = option specifies the name of the boundary condition type one wants to use. dofs= specifies which DoF we want to use. It should be noted that, more than one DoF can be accepted, for instance, dofs=ux uy . boundary= specifies the name of the boundary, which we want to apply the related boundary condition. The name of the boundary should be defined in your mesh file. For the built-in mesh, we use left and right for the point/line/surface at xmin and xmax . Similarly, bottom and top are used for the line/surface at ymin and ymax . Then back and front are used for the surface at zmin and zmax . value= specifies the boundary value we want to use. It should be a single value, instead of several numbers. If one wants to apply the time dependent boundary condition, then he can use value=t*2.0 . Thus the boundary value will change overtime. supported boundary condition type The full list of the available boundary condition type is: type=dirichlet type=nodaldirichlet type=neumann type=nodalneumann type=user1bc[,user2bc,user3bc,...] type=user1dirichletbc[,user2dirichletbc,...]","title":"bcs block"},{"location":"Document/block-bcs/#bcs-block","text":"The block [bcs] is used to apply the different types of boundary conditions, i.e. Dirichlet boundary condition, Neumann boundary condition, Robin boundary condition, as well as User-Defined-BC ( UBC ). This block's layout looks as follows: [bcs] [mybc1] type=dirichlet dofs=dof1 boundary=left right ... value=bcvalue [end] [end]","title":"[bcs] block"},{"location":"Document/block-bcs/#options","text":"The type = option specifies the name of the boundary condition type one wants to use. dofs= specifies which DoF we want to use. It should be noted that, more than one DoF can be accepted, for instance, dofs=ux uy . boundary= specifies the name of the boundary, which we want to apply the related boundary condition. The name of the boundary should be defined in your mesh file. For the built-in mesh, we use left and right for the point/line/surface at xmin and xmax . Similarly, bottom and top are used for the line/surface at ymin and ymax . Then back and front are used for the surface at zmin and zmax . value= specifies the boundary value we want to use. It should be a single value, instead of several numbers. If one wants to apply the time dependent boundary condition, then he can use value=t*2.0 . Thus the boundary value will change overtime.","title":"options"},{"location":"Document/block-bcs/#supported-boundary-condition-type","text":"The full list of the available boundary condition type is: type=dirichlet type=nodaldirichlet type=neumann type=nodalneumann type=user1bc[,user2bc,user3bc,...] type=user1dirichletbc[,user2dirichletbc,...]","title":"supported boundary condition type"},{"location":"Document/block-dofs/","tags":["blocks","input file","dofs"],"text":"[dofs] block The degree of freedom (DoF) or the degrees of freedom (DoFs) can be used to define the name of each DoF and also to apply the necessary boundary conditions ( [bcs] ), elements ( [elmts] ), and so on. The [dofs] block looks like below: [dofs] name=dof1 dof2 dof3 ... [end] [dofs] block option The name= option specifies the name of each DoF. One should keep in mind that, the order of the name indicates the index of each DoFs. For instance, we need two displacements, namely disp_x and disp_y , if we want to do a 2D elastic analysis. The block of [dofs] should therefore be specified as: [dofs] name=disp_x disp_y [end] where disp_x is the first DoF(index=1), disp_y is the second DoF(index=2). That's all, name= is the only option in [dofs] block, nothing else.","title":"dofs block"},{"location":"Document/block-dofs/#dofs-block","text":"The degree of freedom (DoF) or the degrees of freedom (DoFs) can be used to define the name of each DoF and also to apply the necessary boundary conditions ( [bcs] ), elements ( [elmts] ), and so on. The [dofs] block looks like below: [dofs] name=dof1 dof2 dof3 ... [end]","title":"[dofs] block"},{"location":"Document/block-dofs/#dofs-block-option","text":"The name= option specifies the name of each DoF. One should keep in mind that, the order of the name indicates the index of each DoFs. For instance, we need two displacements, namely disp_x and disp_y , if we want to do a 2D elastic analysis. The block of [dofs] should therefore be specified as: [dofs] name=disp_x disp_y [end] where disp_x is the first DoF(index=1), disp_y is the second DoF(index=2). That's all, name= is the only option in [dofs] block, nothing else.","title":"[dofs] block option"},{"location":"Document/block-elmts/","tags":["blocks","input file","elmts"],"text":"[elmts] block The block [elmts] is used to describe the model that we plan to use according to your particular problem. This block's layout looks as follows: [elmts] [subelmts1] type=elment-type2 dofs=dof1 dof2 mate=mate-name1 domain=geometry-domain-name1 [end] [subelmts2] type=elment-type2 dofs=dof1 dof2 mate=mate-name2 domain=geometry-domain-name2 [end] ... [end] options The type = option specifies the name of the element type (or the physical model) one wants to use. dofs= specifies which DoFs we want to use, it should be noted that one of the names in your [dofs] block must be the name we used here. mate= gives the material name, which should be the block name in your material block, not the material type name!!! This option can be ignored, then your element will not call any material calculation. domain= determines which domain will be applied to the current element. Users don't usually need this option, then all of your mesh domains will be used by default. supported element type The full list of the available element type is: type=poisson type=mechanics type=diffusion type=cahnhilliard type=user1[,...,user20]","title":"elmts block"},{"location":"Document/block-elmts/#elmts-block","text":"The block [elmts] is used to describe the model that we plan to use according to your particular problem. This block's layout looks as follows: [elmts] [subelmts1] type=elment-type2 dofs=dof1 dof2 mate=mate-name1 domain=geometry-domain-name1 [end] [subelmts2] type=elment-type2 dofs=dof1 dof2 mate=mate-name2 domain=geometry-domain-name2 [end] ... [end]","title":"[elmts] block"},{"location":"Document/block-elmts/#options","text":"The type = option specifies the name of the element type (or the physical model) one wants to use. dofs= specifies which DoFs we want to use, it should be noted that one of the names in your [dofs] block must be the name we used here. mate= gives the material name, which should be the block name in your material block, not the material type name!!! This option can be ignored, then your element will not call any material calculation. domain= determines which domain will be applied to the current element. Users don't usually need this option, then all of your mesh domains will be used by default.","title":"options"},{"location":"Document/block-elmts/#supported-element-type","text":"The full list of the available element type is: type=poisson type=mechanics type=diffusion type=cahnhilliard type=user1[,...,user20]","title":"supported element type"},{"location":"Document/block-ics/","tags":["blocks","input file","ics"],"text":"[ics] block The block [ics] is used to apply the initial condition for the DoFs. This block's layout looks as follows: [ics] [ic1] type=const dof=dof1 domain=domain-name params=val1 val2 ... [end] ... [end] options The type = option specifies the name of the initial condition type one wants to use. dof= specifies the name of the DoF. domain= indicates the domain name where the initial condition will be applied. params= gives the parameters which will be used in the initial condition calculation. supported initial condition type The full list of the available initial condition typ is: type=const type=random type=circle type=sphere type=rectangle type=cubic","title":"ics block"},{"location":"Document/block-ics/#ics-block","text":"The block [ics] is used to apply the initial condition for the DoFs. This block's layout looks as follows: [ics] [ic1] type=const dof=dof1 domain=domain-name params=val1 val2 ... [end] ... [end]","title":"[ics] block"},{"location":"Document/block-ics/#options","text":"The type = option specifies the name of the initial condition type one wants to use. dof= specifies the name of the DoF. domain= indicates the domain name where the initial condition will be applied. params= gives the parameters which will be used in the initial condition calculation.","title":"options"},{"location":"Document/block-ics/#supported-initial-condition-type","text":"The full list of the available initial condition typ is: type=const type=random type=circle type=sphere type=rectangle type=cubic","title":"supported initial condition type"},{"location":"Document/block-mates/","tags":["blocks","input file","mates"],"text":"[mates] block The block [mates] is used to calculate the material properties we plan to use according to our model, therefore, the material properties will be used by the [elmts] block. This block's layout looks as follows: [mates] [mymate1] type=linearelastic params=210.0 0.3 [end] [mymate2] type=linearelastic params=410.0 0.2 [end] ... [end] It should be noted that, the name of the block mymate1 should be the same as the one you give in [elmts] subblock(the mate=mymate1 option). options The type = option specifies the name of the element type (or the physical model) one wants to use. params= specifies the parameters we want to use in the material property calculation. supported material type The full list of the available element type is: type=constpoisson type=linearelastic type=cahnhilliard type=user1[,...,user10]","title":"mate block"},{"location":"Document/block-mates/#mates-block","text":"The block [mates] is used to calculate the material properties we plan to use according to our model, therefore, the material properties will be used by the [elmts] block. This block's layout looks as follows: [mates] [mymate1] type=linearelastic params=210.0 0.3 [end] [mymate2] type=linearelastic params=410.0 0.2 [end] ... [end] It should be noted that, the name of the block mymate1 should be the same as the one you give in [elmts] subblock(the mate=mymate1 option).","title":"[mates] block"},{"location":"Document/block-mates/#options","text":"The type = option specifies the name of the element type (or the physical model) one wants to use. params= specifies the parameters we want to use in the material property calculation.","title":"options"},{"location":"Document/block-mates/#supported-material-type","text":"The full list of the available element type is: type=constpoisson type=linearelastic type=cahnhilliard type=user1[,...,user10]","title":"supported material type"},{"location":"Document/block-mesh/","tags":["blocks","input file","mesh"],"text":"[mesh] block The format of the block is: [mesh] type=asfem dim=1 xmin=0.0 xmax=1.0 nx=10 meshtype=edge2 savemesh=true [end] [mesh] block options type= option specifies the type of mesh generation we plan to use. We are offering two kinds of mesh generation in AsFem. The first one is the built-in mesh generation for a regular domain, i.e. the straight line (1d), the rectangle domain (2d), and the cubic domain (3d). For the second one, users can import their favorite mesh from other packages, like gmsh ( type=gmsh ) or netgen ( type=gmsh2 ). dim= determines the domain's dimension, which should be 1, 2, or 3. xmin= and xmax= denote the size of the domain, you will need ymin= and ymax= for the 2D case, and zmin= and zmax= in the 3D case. One can also ignore these options, by default, the size of the domain will be unit, namely [1] in 1D, [1,1] in 2D, [1,1,1] in 3D. Simultaneously, nx , ny , and nz represent the number of mesh along these three axes, respectively. meshtype= option offers the choices of different kinds of mesh, for instance, the second order Lagrange mesh in 1D case can be obtained via meshtype=edge3 . Currently, AsFem offers: edge2,edge3,edge4 // in 1D case quad4,quad8,quad9 // in 2D case hex8, hex20,hex27 // in 3D case If one want to save the created mesh, one will need the savemesh=true option. The mesh will be saved as a .vtu file, which should be named as 'your_input_file_name'+'_mesh.vtu' ( .i is removed from your input file name). For example, if your input file is: test.i , then the mesh file name is: test_mesh.vtu .","title":"mesh block"},{"location":"Document/block-mesh/#mesh-block","text":"The format of the block is: [mesh] type=asfem dim=1 xmin=0.0 xmax=1.0 nx=10 meshtype=edge2 savemesh=true [end]","title":"[mesh] block"},{"location":"Document/block-mesh/#mesh-block-options","text":"type= option specifies the type of mesh generation we plan to use. We are offering two kinds of mesh generation in AsFem. The first one is the built-in mesh generation for a regular domain, i.e. the straight line (1d), the rectangle domain (2d), and the cubic domain (3d). For the second one, users can import their favorite mesh from other packages, like gmsh ( type=gmsh ) or netgen ( type=gmsh2 ). dim= determines the domain's dimension, which should be 1, 2, or 3. xmin= and xmax= denote the size of the domain, you will need ymin= and ymax= for the 2D case, and zmin= and zmax= in the 3D case. One can also ignore these options, by default, the size of the domain will be unit, namely [1] in 1D, [1,1] in 2D, [1,1,1] in 3D. Simultaneously, nx , ny , and nz represent the number of mesh along these three axes, respectively. meshtype= option offers the choices of different kinds of mesh, for instance, the second order Lagrange mesh in 1D case can be obtained via meshtype=edge3 . Currently, AsFem offers: edge2,edge3,edge4 // in 1D case quad4,quad8,quad9 // in 2D case hex8, hex20,hex27 // in 3D case If one want to save the created mesh, one will need the savemesh=true option. The mesh will be saved as a .vtu file, which should be named as 'your_input_file_name'+'_mesh.vtu' ( .i is removed from your input file name). For example, if your input file is: test.i , then the mesh file name is: test_mesh.vtu .","title":"[mesh] block options"},{"location":"Document/block-nonlinearsolver/","tags":["blocks","input file","nonlinear solver"],"text":"[nonlinearsolver] block The block [nonlinearsolver] is used for the newton-raphson nonlinear iteration. This block's layout looks as follows: [nonlinearsolver] type=nr maxiters=25 r_rel_tol=1.0e-8 r_abs_tol=1.0e-7 stol=1.0e-16 solver=superlu [end] options The type = option specifies the name of the nonlinear solver method one wants to use. maxiters= specifies maximum nonlinear iterations. r_rel_tol and r_abs_tol represent the relative and absolute errors of the residual( \\(||R||\\) ). stol= determines tolerance of the displacement error, namely \\(||\\Delta U||\\) . solver= indicates the name of linear solver, it could be: ksp , mumps , and superlu . supported nonlinear solver method The full list of the available nonlinear solver method is: type=nr // for newton-raphson with line search, the default one type=newtonls // same as the first one type=newtontr // NR with trust region method type=bfgs // BFGS method type=broyden // Broyden method","title":"nonlinear solver block"},{"location":"Document/block-nonlinearsolver/#nonlinearsolver-block","text":"The block [nonlinearsolver] is used for the newton-raphson nonlinear iteration. This block's layout looks as follows: [nonlinearsolver] type=nr maxiters=25 r_rel_tol=1.0e-8 r_abs_tol=1.0e-7 stol=1.0e-16 solver=superlu [end]","title":"[nonlinearsolver] block"},{"location":"Document/block-nonlinearsolver/#options","text":"The type = option specifies the name of the nonlinear solver method one wants to use. maxiters= specifies maximum nonlinear iterations. r_rel_tol and r_abs_tol represent the relative and absolute errors of the residual( \\(||R||\\) ). stol= determines tolerance of the displacement error, namely \\(||\\Delta U||\\) . solver= indicates the name of linear solver, it could be: ksp , mumps , and superlu .","title":"options"},{"location":"Document/block-nonlinearsolver/#supported-nonlinear-solver-method","text":"The full list of the available nonlinear solver method is: type=nr // for newton-raphson with line search, the default one type=newtonls // same as the first one type=newtontr // NR with trust region method type=bfgs // BFGS method type=broyden // Broyden method","title":"supported nonlinear solver method"},{"location":"Document/block-projection/","tags":["blocks","input file","projection"],"text":"[projection] block The block [projection] is used for projecting the quantities of the gauss point to the nodal point. This block's layout looks as follows: [projection] name=x1 x2 x3 scalarmate=mate1 mate2 ... vectormate=vmat1 vmat2 ... rank2mate=stress strain ... rank4mate=jacobian ... [end] options The name= option specifies the name of the scalar value you want to project, it should be calculated/defined in your element, it is independent with the material system. scalarmate= specifies the name of scalar type materials you want to project, which should be defined/calculated in your materials. For example, Mate.ScalarMaterials(\"myscalar\")=0.0 , where \"myscalar\" is the name for the vector type material. vectormate= specifies the name of vector type materials you want to project, which should be defined/calculated in your materials. For example, Mate.VectorMaterials(\"myvector\")=1.0 , where \"myvector\" is the name for the vector type material. rank2mate= specifies the name of rank-2 tensor type materials you want to project, which should be defined/calculated in your materials. For example, Mate.Rank2Materials(\"mystress\")=1.0 , where \"mystress\" is the name for the rank-2 tensor type material. rank4mate= specifies the name of rank-4 tensor type materials you want to project, which should be defined/calculated in your materials. For example, Mate.Rank4Materials(\"myjacobian\")=1.0 , where \"myjacobian\" is the name for the rank-4 tensor type material. Once you put the correct name of the material properties there, AsFem will automatically save them into the result file. Then you can check them easily in the Paraview.","title":"projection block"},{"location":"Document/block-projection/#projection-block","text":"The block [projection] is used for projecting the quantities of the gauss point to the nodal point. This block's layout looks as follows: [projection] name=x1 x2 x3 scalarmate=mate1 mate2 ... vectormate=vmat1 vmat2 ... rank2mate=stress strain ... rank4mate=jacobian ... [end]","title":"[projection] block"},{"location":"Document/block-projection/#options","text":"The name= option specifies the name of the scalar value you want to project, it should be calculated/defined in your element, it is independent with the material system. scalarmate= specifies the name of scalar type materials you want to project, which should be defined/calculated in your materials. For example, Mate.ScalarMaterials(\"myscalar\")=0.0 , where \"myscalar\" is the name for the vector type material. vectormate= specifies the name of vector type materials you want to project, which should be defined/calculated in your materials. For example, Mate.VectorMaterials(\"myvector\")=1.0 , where \"myvector\" is the name for the vector type material. rank2mate= specifies the name of rank-2 tensor type materials you want to project, which should be defined/calculated in your materials. For example, Mate.Rank2Materials(\"mystress\")=1.0 , where \"mystress\" is the name for the rank-2 tensor type material. rank4mate= specifies the name of rank-4 tensor type materials you want to project, which should be defined/calculated in your materials. For example, Mate.Rank4Materials(\"myjacobian\")=1.0 , where \"myjacobian\" is the name for the rank-4 tensor type material. Once you put the correct name of the material properties there, AsFem will automatically save them into the result file. Then you can check them easily in the Paraview.","title":"options"},{"location":"Document/block-qpoint/","tags":["blocks","input file","qpoint"],"text":"[qpoint] block The block [qpoint] is used for the gauss point integration. This block's layout looks as follows: [qpoint] type=gauss order=3 [end] options The type = option specifies the type name of the gauss point integration. order= specifies gauss integration order(it's not the number of gauss points, instead, it's the order !) supported gauss integration method The full list of the available gauss integration is: type=gauss type=gausslobatto","title":"qpoint block"},{"location":"Document/block-qpoint/#qpoint-block","text":"The block [qpoint] is used for the gauss point integration. This block's layout looks as follows: [qpoint] type=gauss order=3 [end]","title":"[qpoint] block"},{"location":"Document/block-qpoint/#options","text":"The type = option specifies the type name of the gauss point integration. order= specifies gauss integration order(it's not the number of gauss points, instead, it's the order !)","title":"options"},{"location":"Document/block-qpoint/#supported-gauss-integration-method","text":"The full list of the available gauss integration is: type=gauss type=gausslobatto","title":"supported gauss integration method"},{"location":"Document/block-timestepping/","tags":["blocks","input file","timestepping"],"text":"[timestepping] block The block [timestepping] is used for the transient analysis. This block's layout looks as follows: [timestepping] type=be dt=1.0e-5 time=1.0e3 adaptive=true optiters=3 growthfactor=1.1 cutfactor=0.85 dtmin=1.0e-12 dtmax=1.0e1 [end] options The type = option specifies the name of the time integration method one wants to use. dt= specifies initial \\(\\Delta_{t}\\) . time= defines the final time. adaptive=true enables the adaptive time stepping. It's disabled by default. optiters= determines the critical nonlinear iterations for increasing or decreasing the \\(\\Delta_{t}\\) . growthfactor= and cutfactor= represent the growth factor and cut back factor for adaptive time stepping, respectively. dtmin and dtmax determine the minimum and maximum value of \\(\\Delta_{t}\\) . supported time stepping method The full list of the available time stepping method is: type=be type=cn type=bdf2","title":"timestepping block"},{"location":"Document/block-timestepping/#timestepping-block","text":"The block [timestepping] is used for the transient analysis. This block's layout looks as follows: [timestepping] type=be dt=1.0e-5 time=1.0e3 adaptive=true optiters=3 growthfactor=1.1 cutfactor=0.85 dtmin=1.0e-12 dtmax=1.0e1 [end]","title":"[timestepping] block"},{"location":"Document/block-timestepping/#options","text":"The type = option specifies the name of the time integration method one wants to use. dt= specifies initial \\(\\Delta_{t}\\) . time= defines the final time. adaptive=true enables the adaptive time stepping. It's disabled by default. optiters= determines the critical nonlinear iterations for increasing or decreasing the \\(\\Delta_{t}\\) . growthfactor= and cutfactor= represent the growth factor and cut back factor for adaptive time stepping, respectively. dtmin and dtmax determine the minimum and maximum value of \\(\\Delta_{t}\\) .","title":"options"},{"location":"Document/block-timestepping/#supported-time-stepping-method","text":"The full list of the available time stepping method is: type=be type=cn type=bdf2","title":"supported time stepping method"},{"location":"Examples/PhaseFieldFracture/","tags":["examples","input file","mesh","dofs","elmts","mates","stress","umat","phase field","fracture"],"text":"Introduction In this example, we will try to solve the phase-field fracture model which is implemented based on Prof. Miehe's Model . Model In this model, the damage phase is described by an order parameter \\(d\\) which varies smoothly from 0 (undamaged case) to 1 (fully damaged case). Therefore, the system free energy can be read as follows: $$ \\begin{equation} \\psi=\\psi_{d}+\\psi_{e} \\label{eq:psi} \\tag{1} \\end{equation} $$ where \\(g(d)\\) is the degradation function, and the damage phase free energy \\(\\psi_{d}\\) is given as follows: $$ \\begin{equation} \\psi_{d}=\\mathcal{G}_{c}(\\frac{d^{2}}{2l}+\\frac{l}{2}\\lvert\\nabla d\\rvert^{2}) \\label{eq:psi-d} \\tag{2} \\end{equation} $$ with \\(\\mathcal{G}_{c}\\) and \\(l\\) being the critical energy release rate and the length scale parameter, respectively. The elastic free energy can be defined as follows: $$ \\begin{equation} \\psi_{e}=g(d)\\psi_{e}^{+}+\\psi_{e}^{-} \\label{eq:psi-e} \\tag{3} \\end{equation} $$ where $$ \\begin{equation} \\psi_{e}^{+}=\\frac{\\lambda}{2}\\langle\\mathrm{tr}(\\mathbf{\\varepsilon})\\rangle_{+}^{2}+\\mu \\mathrm{tr}[\\mathbf{\\varepsilon}_{+}^{2}] \\label{eq:psi-e-positive} \\tag{4} \\end{equation} $$ and $$ \\begin{equation} \\psi_{e}^{-}=\\frac{\\lambda}{2}\\langle\\mathrm{tr}(\\mathbf{\\varepsilon})\\rangle_{-}^{2}+\\mu \\mathrm{tr}[\\mathbf{\\varepsilon}_{-}^{2}] \\label{eq:psi-e-negative} \\tag{5} \\end{equation} $$ Here, \\(\\lambda\\) and \\(\\mu\\) are the lame constant and shear moduli, respectively. The positive and negative bracket operators are given as follows: $$ \\begin{equation} \\langle x\\rangle_{+}=\\frac{x+|x|}{2}\\ ,\\quad \\langle x\\rangle_{-}=\\frac{x-|x|}{2} \\label{eq:bracket} \\tag{6} \\end{equation} $$ Thus the stress can be defined as follows: $$ \\begin{equation} \\mathbf{\\sigma}=\\frac{\\partial\\psi}{\\partial\\mathbf{\\varepsilon}} =g(d)[\\lambda\\langle\\mathrm{tr}[\\mathbf{\\varepsilon}]\\rangle_{+}\\mathbf{I}+2\\mu\\mathbf{\\varepsilon}_{+}]+[\\lambda\\langle\\mathrm{tr}[\\mathbf{\\varepsilon}]\\rangle_{-}\\mathbf{I}+2\\mu\\mathbf{\\varepsilon}_{-}] \\label{eq:stress} \\tag{7} \\end{equation} $$ The governing equaitons for this model are list below: $$ \\begin{equation} \\mathbf{\\nabla}\\cdot\\mathbf{\\sigma}=\\mathbf{0} \\label{eq:stress-equilibrium} \\tag{8} \\end{equation} $$ and $$ \\begin{equation} \\eta\\frac{\\partial d}{\\partial t}=2(1-d)\\mathcal{H}-\\frac{\\mathcal{G}_{c}}{l}(d-l^{2}\\Delta d) \\label{eq:damage-equation} \\tag{9} \\end{equation} $$ where \\(\\eta\\) is the viscosity coefficient. The history variable \\(\\mathcal{H}\\) is calculated as follows: \\[ \\begin{equation} \\mathcal{H}= \\begin{cases} \\psi_{e}^{+} & \\mathrm{if}\\quad\\psi_{e}^{+}>\\mathcal{H}_{n}\\\\ \\mathcal{H}_{n} &\\mathrm{otherwise} \\end{cases} \\label{eq:hist} \\tag{10} \\end{equation} \\] Input file In the example/pffracture folder, there are several geo file, which can be used to generate the msh mesh file for your simulation. Before we start, you should have the mesh file. Mesh In this case, we'll import the mesh from gmsh , which can be done as follows: [mesh] type=gmsh file=sample.msh [end] Here, you should use gmsh to generate the related msh file! Dofs Next, you need to define the dofs, it should be \\(d\\) , \\(u_{x}\\) , and \\(u_{y}\\) for 2d case, and \\(d\\) , \\(u_{x}\\) , \\(u_{y}\\) , and \\(u_{z}\\) for 3d case. The [dofs] block should looks like: [dofs] name=d ux uy [end] or [dofs] name=d ux uy uz [end] Here, the sequence of your dofs name matters !!! [elmts] and [mates] The governings in Eq. \\(\\eqref{eq:stress-equilibrium}\\) and Eq. \\(\\eqref{eq:damage-equation}\\) can be implemented by using the following elmts : [elmts] [myfracture] type=miehefrac dofs=d ux uy mate=myfracmate [end] [end] where type=miehefrac tells AsFem, our users want to call the phase-field fracture model. For the material calculation, as mentioned before, several parameters are required, i.e., \\(E\\) , \\(\\nu\\) for the Youngs modulus and poisson ration, \\(\\eta\\) , \\(\\mathcal{G}_{c}\\) , and \\(l\\) for the damage evolution. Therefore, the related material block can be given as follows: [mates] [myfracmate] type=miehefracmate params=121.15 80.77 2.7e-3 0.012 1.0e-6 // lambda mu Gc L viscosity [end] [end] It should be mentioned that, the de-coupled or staggered solution can be done easily by introducing the usehist parameter as follows: [mates] [myfracmate] type=miehefracmate params=121.15 80.77 2.7e-3 0.012 1.0e-6 1 // lambda mu Gc L viscosity usehist [end] [end] then, your \\(\\mathcal{H}\\) will always use the \\(\\mathcal{H}_{old}\\) value from previous step. boundary condition For the tensile test, one can use the following bcs : [bcs] [fixux] type=dirichlet dofs=ux value=0.0 boundary=left right top bottom [end] [fixuy] type=dirichlet dofs=uy value=0.0 boundary=bottom [end] [load] type=dirichlet dofs=uy value=1.0*t boundary=top [end] [end] and for the shear failure test, one can use: [bcs] [fixux] type=dirichlet dofs=ux value=0.0 boundary=bottom [end] [fixuy] type=dirichlet dofs=uy value=0.0 boundary=bottom left right top [end] [load] type=dirichlet dofs=ux value=1.0*t boundary=top [end] [end] Done? Yulp, all the things is done! Run it in AsFem Now, let's try your first phase-field fracture model in AsFem. You can create a new text file and name it as tensile.i or whatever you like. Then copy the following lines into your input file: [mesh] type=gmsh file=sample.msh [end] [dofs] name=d ux uy [end] [elmts] [myfracture] type=miehefrac dofs=d ux uy mate=myfracmate [end] [end] [mates] [myfracmate] type=miehefracmate params=121.15 80.77 2.7e-3 0.012 1.0e-6 // lambda mu Gc L viscosity [end] [end] [nonlinearsolver] type=nr maxiters=15 r_rel_tol=1.0e-10 r_abs_tol=5.5e-7 [end] [ics] [constd] type=const dof=d params=0.0 [end] [end] [output] type=vtu interval=20 [end] [timestepping] type=be dt=1.0e-5 time=5.0e-5 adaptive=false optiters=3 growthfactor=1.1 cutfactor=0.85 dtmin=1.0e-12 dtmax=1.0e-4 [end] [projection] scalarmate=vonMises [end] [bcs] [fixux] type=dirichlet dofs=ux value=0.0 boundary=left right top bottom [end] [fixuy] type=dirichlet dofs=uy value=0.0 boundary=bottom [end] [load] type=dirichlet dofs=uy value=1.0*t boundary=top [end] [end] [job] type=transient debug=dep [end] You can also find the complete input file in examples/pffracture/miehe-tensile.i . If everything goes well, you can see the following image in your Paraview :","title":"Fracture"},{"location":"Examples/PhaseFieldFracture/#introduction","text":"In this example, we will try to solve the phase-field fracture model which is implemented based on Prof. Miehe's Model .","title":"Introduction"},{"location":"Examples/PhaseFieldFracture/#model","text":"In this model, the damage phase is described by an order parameter \\(d\\) which varies smoothly from 0 (undamaged case) to 1 (fully damaged case). Therefore, the system free energy can be read as follows: $$ \\begin{equation} \\psi=\\psi_{d}+\\psi_{e} \\label{eq:psi} \\tag{1} \\end{equation} $$ where \\(g(d)\\) is the degradation function, and the damage phase free energy \\(\\psi_{d}\\) is given as follows: $$ \\begin{equation} \\psi_{d}=\\mathcal{G}_{c}(\\frac{d^{2}}{2l}+\\frac{l}{2}\\lvert\\nabla d\\rvert^{2}) \\label{eq:psi-d} \\tag{2} \\end{equation} $$ with \\(\\mathcal{G}_{c}\\) and \\(l\\) being the critical energy release rate and the length scale parameter, respectively. The elastic free energy can be defined as follows: $$ \\begin{equation} \\psi_{e}=g(d)\\psi_{e}^{+}+\\psi_{e}^{-} \\label{eq:psi-e} \\tag{3} \\end{equation} $$ where $$ \\begin{equation} \\psi_{e}^{+}=\\frac{\\lambda}{2}\\langle\\mathrm{tr}(\\mathbf{\\varepsilon})\\rangle_{+}^{2}+\\mu \\mathrm{tr}[\\mathbf{\\varepsilon}_{+}^{2}] \\label{eq:psi-e-positive} \\tag{4} \\end{equation} $$ and $$ \\begin{equation} \\psi_{e}^{-}=\\frac{\\lambda}{2}\\langle\\mathrm{tr}(\\mathbf{\\varepsilon})\\rangle_{-}^{2}+\\mu \\mathrm{tr}[\\mathbf{\\varepsilon}_{-}^{2}] \\label{eq:psi-e-negative} \\tag{5} \\end{equation} $$ Here, \\(\\lambda\\) and \\(\\mu\\) are the lame constant and shear moduli, respectively. The positive and negative bracket operators are given as follows: $$ \\begin{equation} \\langle x\\rangle_{+}=\\frac{x+|x|}{2}\\ ,\\quad \\langle x\\rangle_{-}=\\frac{x-|x|}{2} \\label{eq:bracket} \\tag{6} \\end{equation} $$ Thus the stress can be defined as follows: $$ \\begin{equation} \\mathbf{\\sigma}=\\frac{\\partial\\psi}{\\partial\\mathbf{\\varepsilon}} =g(d)[\\lambda\\langle\\mathrm{tr}[\\mathbf{\\varepsilon}]\\rangle_{+}\\mathbf{I}+2\\mu\\mathbf{\\varepsilon}_{+}]+[\\lambda\\langle\\mathrm{tr}[\\mathbf{\\varepsilon}]\\rangle_{-}\\mathbf{I}+2\\mu\\mathbf{\\varepsilon}_{-}] \\label{eq:stress} \\tag{7} \\end{equation} $$ The governing equaitons for this model are list below: $$ \\begin{equation} \\mathbf{\\nabla}\\cdot\\mathbf{\\sigma}=\\mathbf{0} \\label{eq:stress-equilibrium} \\tag{8} \\end{equation} $$ and $$ \\begin{equation} \\eta\\frac{\\partial d}{\\partial t}=2(1-d)\\mathcal{H}-\\frac{\\mathcal{G}_{c}}{l}(d-l^{2}\\Delta d) \\label{eq:damage-equation} \\tag{9} \\end{equation} $$ where \\(\\eta\\) is the viscosity coefficient. The history variable \\(\\mathcal{H}\\) is calculated as follows: \\[ \\begin{equation} \\mathcal{H}= \\begin{cases} \\psi_{e}^{+} & \\mathrm{if}\\quad\\psi_{e}^{+}>\\mathcal{H}_{n}\\\\ \\mathcal{H}_{n} &\\mathrm{otherwise} \\end{cases} \\label{eq:hist} \\tag{10} \\end{equation} \\]","title":"Model"},{"location":"Examples/PhaseFieldFracture/#input-file","text":"In the example/pffracture folder, there are several geo file, which can be used to generate the msh mesh file for your simulation. Before we start, you should have the mesh file.","title":"Input file"},{"location":"Examples/PhaseFieldFracture/#mesh","text":"In this case, we'll import the mesh from gmsh , which can be done as follows: [mesh] type=gmsh file=sample.msh [end] Here, you should use gmsh to generate the related msh file!","title":"Mesh"},{"location":"Examples/PhaseFieldFracture/#dofs","text":"Next, you need to define the dofs, it should be \\(d\\) , \\(u_{x}\\) , and \\(u_{y}\\) for 2d case, and \\(d\\) , \\(u_{x}\\) , \\(u_{y}\\) , and \\(u_{z}\\) for 3d case. The [dofs] block should looks like: [dofs] name=d ux uy [end] or [dofs] name=d ux uy uz [end] Here, the sequence of your dofs name matters !!!","title":"Dofs"},{"location":"Examples/PhaseFieldFracture/#elmts-and-mates","text":"The governings in Eq. \\(\\eqref{eq:stress-equilibrium}\\) and Eq. \\(\\eqref{eq:damage-equation}\\) can be implemented by using the following elmts : [elmts] [myfracture] type=miehefrac dofs=d ux uy mate=myfracmate [end] [end] where type=miehefrac tells AsFem, our users want to call the phase-field fracture model. For the material calculation, as mentioned before, several parameters are required, i.e., \\(E\\) , \\(\\nu\\) for the Youngs modulus and poisson ration, \\(\\eta\\) , \\(\\mathcal{G}_{c}\\) , and \\(l\\) for the damage evolution. Therefore, the related material block can be given as follows: [mates] [myfracmate] type=miehefracmate params=121.15 80.77 2.7e-3 0.012 1.0e-6 // lambda mu Gc L viscosity [end] [end] It should be mentioned that, the de-coupled or staggered solution can be done easily by introducing the usehist parameter as follows: [mates] [myfracmate] type=miehefracmate params=121.15 80.77 2.7e-3 0.012 1.0e-6 1 // lambda mu Gc L viscosity usehist [end] [end] then, your \\(\\mathcal{H}\\) will always use the \\(\\mathcal{H}_{old}\\) value from previous step.","title":"[elmts] and [mates]"},{"location":"Examples/PhaseFieldFracture/#boundary-condition","text":"For the tensile test, one can use the following bcs : [bcs] [fixux] type=dirichlet dofs=ux value=0.0 boundary=left right top bottom [end] [fixuy] type=dirichlet dofs=uy value=0.0 boundary=bottom [end] [load] type=dirichlet dofs=uy value=1.0*t boundary=top [end] [end] and for the shear failure test, one can use: [bcs] [fixux] type=dirichlet dofs=ux value=0.0 boundary=bottom [end] [fixuy] type=dirichlet dofs=uy value=0.0 boundary=bottom left right top [end] [load] type=dirichlet dofs=ux value=1.0*t boundary=top [end] [end] Done? Yulp, all the things is done!","title":"boundary condition"},{"location":"Examples/PhaseFieldFracture/#run-it-in-asfem","text":"Now, let's try your first phase-field fracture model in AsFem. You can create a new text file and name it as tensile.i or whatever you like. Then copy the following lines into your input file: [mesh] type=gmsh file=sample.msh [end] [dofs] name=d ux uy [end] [elmts] [myfracture] type=miehefrac dofs=d ux uy mate=myfracmate [end] [end] [mates] [myfracmate] type=miehefracmate params=121.15 80.77 2.7e-3 0.012 1.0e-6 // lambda mu Gc L viscosity [end] [end] [nonlinearsolver] type=nr maxiters=15 r_rel_tol=1.0e-10 r_abs_tol=5.5e-7 [end] [ics] [constd] type=const dof=d params=0.0 [end] [end] [output] type=vtu interval=20 [end] [timestepping] type=be dt=1.0e-5 time=5.0e-5 adaptive=false optiters=3 growthfactor=1.1 cutfactor=0.85 dtmin=1.0e-12 dtmax=1.0e-4 [end] [projection] scalarmate=vonMises [end] [bcs] [fixux] type=dirichlet dofs=ux value=0.0 boundary=left right top bottom [end] [fixuy] type=dirichlet dofs=uy value=0.0 boundary=bottom [end] [load] type=dirichlet dofs=uy value=1.0*t boundary=top [end] [end] [job] type=transient debug=dep [end] You can also find the complete input file in examples/pffracture/miehe-tensile.i . If everything goes well, you can see the following image in your Paraview :","title":"Run it in AsFem"},{"location":"Tutorial/step-0/","text":"Write a simple input file: In your input file, the layout of the block should look like: [block_name] type=... option1=... option2=... [end] here, to set the properties we want, we use the [blockname]/[end] bracket pair. Every block pair must therefore end up with an [end] . Note, even inside one wide block there are sub-blocks, each (sub)block itself always has to end up with an [end] . Otherwise, the input file will complain to you about mistakes! For one minimal input file, you need: [mesh] ... [end] and also the Specified Degrees of Freedom ( DoFs ) name or name list that will be displayed in the Paraview when you open the result file (vtu file). Furthermore, when you want to apply the boundary condition, the name of related DoFs is required. [dofs] ... [end] and the element or module you'd like to use: [elmts] ... [end] as well as the necessary information for the analysis(we call it the [job] block) [job] ... [end] To sum up, you at least need: [mesh] ... [end] [dofs] ... [end] [elmts] ... [end] [job] ... [end] However, one can also use the --read-only option to force AsFem to only read the input file but ignore the FEM analysis workflow. The list of all the blocks in full is: [mesh] ... [end] [dofs] ... [end] [elmts] ... [end] [mates] ... [end] [bcs] ... [end] [ics] ... [end] [projection] ... [end] [timestepping] ... [end] [nonlinearsolver] ... [end] [qpoint] ... [end] [job] ... [end] In the following steps, we will introduce you the details of each block and their functions. All the input file can be found in the examples/tutorial folder.","title":"Step-0"},{"location":"Tutorial/step-0/#write-a-simple-input-file","text":"In your input file, the layout of the block should look like: [block_name] type=... option1=... option2=... [end] here, to set the properties we want, we use the [blockname]/[end] bracket pair. Every block pair must therefore end up with an [end] . Note, even inside one wide block there are sub-blocks, each (sub)block itself always has to end up with an [end] . Otherwise, the input file will complain to you about mistakes! For one minimal input file, you need: [mesh] ... [end] and also the Specified Degrees of Freedom ( DoFs ) name or name list that will be displayed in the Paraview when you open the result file (vtu file). Furthermore, when you want to apply the boundary condition, the name of related DoFs is required. [dofs] ... [end] and the element or module you'd like to use: [elmts] ... [end] as well as the necessary information for the analysis(we call it the [job] block) [job] ... [end] To sum up, you at least need: [mesh] ... [end] [dofs] ... [end] [elmts] ... [end] [job] ... [end] However, one can also use the --read-only option to force AsFem to only read the input file but ignore the FEM analysis workflow. The list of all the blocks in full is: [mesh] ... [end] [dofs] ... [end] [elmts] ... [end] [mates] ... [end] [bcs] ... [end] [ics] ... [end] [projection] ... [end] [timestepping] ... [end] [nonlinearsolver] ... [end] [qpoint] ... [end] [job] ... [end] In the following steps, we will introduce you the details of each block and their functions. All the input file can be found in the examples/tutorial folder.","title":"Write a simple input file:"},{"location":"Tutorial/step-1/","tags":["tutorial","input file","mesh"],"text":"Introduction Before we begin the actual FEM simulation, we must define our computation domain and discretize it into multiple subdomains. For this purpose, the [mesh] block is introduced. 1D example Let's take the 1D solid line as an example, this line can be discretized into several 1D Lagrange mesh as follows: [mesh] type=asfem dim=1 xmin=0.0 xmax=1.0 nx=10 meshtype=edge2 [end] Options The type= option specifies the type of mesh generation we plan to use. We are offering two kinds of mesh generation in AsFem. The first one is the built-in mesh generation for a regular domain, i.e. the straight line (1d), the rectangle domain (2d), and the cubic domain (3d). For the second one, users can import their favorite mesh from other packages, like gmsh ( type=gmsh ) or netgen ( type=gmsh2 ). dim= determines the domain's dimension, which should be 1, 2, or 3. xmin= and xmax= denote the size of the domain, you will need ymin= and ymax= for the 2D case, and zmin= and zmax= in the 3D case. One can also ignore these options, by default, the size of the domain will be unit, namely [1] in 1D, [1,1] in 2D, [1,1,1] in 3D. Simultaneously, nx , ny , and nz represent the number of mesh along these three axes, respectively. meshtype= option offers the choices of different kinds of mesh, for instance, the second order Lagrange mesh in 1D case can be obtained via meshtype=edge3 . Currently, AsFem offers: edge2,edge3,edge4 // in 1D case quad4,quad8,quad9 // in 2D case hex8, hex20,hex27 // in 3D case If one want to save the created mesh, one will need the savemesh=true option. The mesh will be saved as a .vtu file, which should be named as 'your_input_file_name'+'_mesh.vtu' ( .i is removed from your input file name). For example, if your input file is: test.i , then the mesh file name is: test_mesh.vtu . Complete mesh block Then the complete [mesh] block should look like: [mesh] type=asfem dim=1 xmin=0.0 xmax=1.0 nx=10 meshtype=edge2 savemesh=true [end] 2D and 3D examples Similarly, for 2D and 3D cases, one can use: [mesh] type=asfem dim=2 xmin=0.0 xmax=1.0 ymin=0.0 ymax=1.0 nx=10 ny=10 meshtype=quad4 [end] and [mesh] type=asfem dim=3 xmin=0.0 xmax=1.0 ymin=0.0 ymax=1.0 zmin=0.0 zmax=1.0 nx=10 ny=10 nz=10 meshtype=hex8 [end] Or, one can also use: [mesh] type=asfem dim=3 nx=10 ny=10 nz=10 meshtype=hex8 [end] then the unit [0,1]x[0,1]x[0,1] 3D domain will be used by default. First try in your AsFem Now, lets try your first example in AsFem. You can create a new text file or simply run the following commands(you can use whatever your like, here we use nano and vim): nano firstrun.i or vim firstrun.i then copy and paste the following [mesh] block into your firstrun.i : [mesh] type=asfem dim=3 nx=10 ny=10 nz=10 meshtype=hex8 savemesh=true [end] save it and then execute your AsFem as follows: asfem -i firstrun.i --read-only or in parallel: mpirun -np 4 asfem -i firstrun.i --read-only Here one need the --read-only option, since we do not have a complete input file but only the [mesh] block. If everthing works fine, you should see the following output: ***************************************************************************** *** Welcome to use AsFem *** *** A Simple Finite Element Method Program *** *** Version: 0.40 Release @ 2021-01-01 *** *** PETSc version: 3.14.3 *** *** License: GPL-3.0 *** *** Author: Yang Bai *** *** Contact: walkandthinker@gmail.com *** *** QQ Group: 879908352 *** *** Website: https://github.com/yangbai90/AsFem *** *** Feel free to use and discuss .:. *** ***************************************************************************** *** Start to create mesh ... *** *** Mesh generation finished ! *** *** Save mesh to [ step1_mesh.vtu] *** ***-----------------------------------------------------------------------*** ***-----------------------------------------------------------------------*** *** Read-only mode analysis is finished ! *** ***************************************************************************** Then, one can use the Paraview to check our 3D mesh, which looks like below: As an exercise for the'[mesh]' block, it is highly recommended to try various options to generate the mesh you need before moving to the next step. The complete input files can be fund in examples/tutorial .","title":"Step-1"},{"location":"Tutorial/step-1/#introduction","text":"Before we begin the actual FEM simulation, we must define our computation domain and discretize it into multiple subdomains. For this purpose, the [mesh] block is introduced.","title":"Introduction"},{"location":"Tutorial/step-1/#1d-example","text":"Let's take the 1D solid line as an example, this line can be discretized into several 1D Lagrange mesh as follows: [mesh] type=asfem dim=1 xmin=0.0 xmax=1.0 nx=10 meshtype=edge2 [end]","title":"1D example"},{"location":"Tutorial/step-1/#options","text":"The type= option specifies the type of mesh generation we plan to use. We are offering two kinds of mesh generation in AsFem. The first one is the built-in mesh generation for a regular domain, i.e. the straight line (1d), the rectangle domain (2d), and the cubic domain (3d). For the second one, users can import their favorite mesh from other packages, like gmsh ( type=gmsh ) or netgen ( type=gmsh2 ). dim= determines the domain's dimension, which should be 1, 2, or 3. xmin= and xmax= denote the size of the domain, you will need ymin= and ymax= for the 2D case, and zmin= and zmax= in the 3D case. One can also ignore these options, by default, the size of the domain will be unit, namely [1] in 1D, [1,1] in 2D, [1,1,1] in 3D. Simultaneously, nx , ny , and nz represent the number of mesh along these three axes, respectively. meshtype= option offers the choices of different kinds of mesh, for instance, the second order Lagrange mesh in 1D case can be obtained via meshtype=edge3 . Currently, AsFem offers: edge2,edge3,edge4 // in 1D case quad4,quad8,quad9 // in 2D case hex8, hex20,hex27 // in 3D case If one want to save the created mesh, one will need the savemesh=true option. The mesh will be saved as a .vtu file, which should be named as 'your_input_file_name'+'_mesh.vtu' ( .i is removed from your input file name). For example, if your input file is: test.i , then the mesh file name is: test_mesh.vtu .","title":"Options"},{"location":"Tutorial/step-1/#complete-mesh-block","text":"Then the complete [mesh] block should look like: [mesh] type=asfem dim=1 xmin=0.0 xmax=1.0 nx=10 meshtype=edge2 savemesh=true [end]","title":"Complete mesh block"},{"location":"Tutorial/step-1/#2d-and-3d-examples","text":"Similarly, for 2D and 3D cases, one can use: [mesh] type=asfem dim=2 xmin=0.0 xmax=1.0 ymin=0.0 ymax=1.0 nx=10 ny=10 meshtype=quad4 [end] and [mesh] type=asfem dim=3 xmin=0.0 xmax=1.0 ymin=0.0 ymax=1.0 zmin=0.0 zmax=1.0 nx=10 ny=10 nz=10 meshtype=hex8 [end] Or, one can also use: [mesh] type=asfem dim=3 nx=10 ny=10 nz=10 meshtype=hex8 [end] then the unit [0,1]x[0,1]x[0,1] 3D domain will be used by default.","title":"2D and 3D examples"},{"location":"Tutorial/step-1/#first-try-in-your-asfem","text":"Now, lets try your first example in AsFem. You can create a new text file or simply run the following commands(you can use whatever your like, here we use nano and vim): nano firstrun.i or vim firstrun.i then copy and paste the following [mesh] block into your firstrun.i : [mesh] type=asfem dim=3 nx=10 ny=10 nz=10 meshtype=hex8 savemesh=true [end] save it and then execute your AsFem as follows: asfem -i firstrun.i --read-only or in parallel: mpirun -np 4 asfem -i firstrun.i --read-only Here one need the --read-only option, since we do not have a complete input file but only the [mesh] block. If everthing works fine, you should see the following output: ***************************************************************************** *** Welcome to use AsFem *** *** A Simple Finite Element Method Program *** *** Version: 0.40 Release @ 2021-01-01 *** *** PETSc version: 3.14.3 *** *** License: GPL-3.0 *** *** Author: Yang Bai *** *** Contact: walkandthinker@gmail.com *** *** QQ Group: 879908352 *** *** Website: https://github.com/yangbai90/AsFem *** *** Feel free to use and discuss .:. *** ***************************************************************************** *** Start to create mesh ... *** *** Mesh generation finished ! *** *** Save mesh to [ step1_mesh.vtu] *** ***-----------------------------------------------------------------------*** ***-----------------------------------------------------------------------*** *** Read-only mode analysis is finished ! *** ***************************************************************************** Then, one can use the Paraview to check our 3D mesh, which looks like below: As an exercise for the'[mesh]' block, it is highly recommended to try various options to generate the mesh you need before moving to the next step. The complete input files can be fund in examples/tutorial .","title":"First try in your AsFem"},{"location":"Tutorial/step-2/","text":"Introduction In step-1 , our mesh was defined. Some necessary information, however, is still missing for a simple FEM analysis. Therefore, we will try to define our degrees of freedom (DoFs) in this step and also the element of our model. In the end, to obtain the final solution, we will apply the related boundary conditions. The poisson equation The issue we want to solve is the Poisson linear equation that reads as follows: $$ \\begin{equation} k\\nabla^{2}\\phi=F \\label{eq:poisson} \\tag{1} \\end{equation} $$ where \\(k\\) and \\(F\\) denote the model's coefficients. Below are the related boundary conditions: $$ \\begin{equation} k\\nabla\\phi\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:neumann} \\tag{2} \\end{equation} $$ and $$ \\begin{equation} \\phi=\\phi_{g}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D} \\label{eq:dirichlet} \\tag{3} \\end{equation} $$ where the Dirichlet boundary condition and Neumann boundary condition are defined by the subscripts \\(D\\) and \\(N\\) . Define the degree of freedom (DoF) The degree of freedom (DoF) or the degrees of freedom (DoFs) can be used to define the name of each DoF and also to apply the necessary boundary conditions ( [bcs] ), elements ( [elmts] ), and so on. The [dofs] block looks like below: [dofs] name=dof1 dof2 dof3 ... [end] Options The name= option specifies the name of each DoF. One should keep in mind that, the order of the name indicates the index of each DoFs. For instance, we need two displacements, namely disp_x and disp_y , if we want to do a 2D elastic analysis. The block of [dofs] should therefore be specified as: [dofs] name=disp_x disp_y [end] where disp_x is the first DoF(index=1), disp_y is the second DoF(index=2). That's all, name= is the only option in [dofs] block, nothing else. For the Poisson equation, because there is only one DoF involved, the final expression of [dofs] should be: [dofs] name=phi [end] Element for Poisson equation The DoF is ready now, but the model in Eq. \\(\\eqref{eq:poisson}\\) is still missing. Thereby, we introduce the [elmts] block for this purpose. This block looks like below: [elmts] [elmt1] type=poisson dofs=phi mate=mymate [end] [end] where type= option specifies the element we want to use, it could be either the built-in elements of AsFem or the user-defined-element ( UEL ). The DoFs that will be used in this element are defined by dofs= . mate= gives the name of the material block that we want to use. Once the [elmts] block is given, the model we defined in Eq. \\(\\eqref{eq:poisson}\\) is ready. Material properties For the coefficients \\(k\\) and \\(F\\) , namely the material properties, they can be calculated or defined via the [mates] block as follows: [mates] [mymate] type=constpoisson params=1.0 1.0e1 [end] [end] where type= specifies the material type name defined in AsFem. params= defines the parameters we want to use in our model, in this case, \\(k=1.0\\) and \\(F=10.0\\) will be used. Boundary conditions The boundary conditions, as mentioned in Eq. \\(\\eqref{eq:dirichlet}\\) and \\(\\eqref{eq:neumann}\\) , can be applied via the [bcs] block. In our case, the Neumann boundary condition in Eq. \\(\\eqref{eq:neumann}\\) is zero, therefore, only the Dirichlet boundary condition need to be considered: [bcs] [fixleft] type=dirichlet dof=phi value=0.1 boundary=left [end] [fixright] type=dirichlet dof=phi value=0.5 boundary=right [end] [end] where type= specifies the different types of boundary conditions supported by AsFem. dof= denotes the name of DoF we want to apply the given boundary conditions. In our case, we constrain the value of \\(\\phi\\) on the left and right side of a rectangle domain to be 0.1 and 0.5, respectively. Static analysis Until now, all the model and boundary conditions are ready. To start the FEM calculation, we need a [job] block to tell AsFem which kind of analysis we want. For the static analysis in this case, it can be given as follows: [job] type=static [end] if one wants to see how the iteration information changes, one can use: [job] type=static debug=dep [end] where debug= option enables some basic information output in your terminal. If you don't want to see too many outputs, then you can use debug=false . Run it in AsFem Now, let's try your second example in AsFem. You can create a new text file and name it as step2.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 nx=50 ny=50 meshtype=quad4 [end] [dofs] name=phi [end] [elmts] [elmt1] type=poisson dofs=phi mate=mymate [end] [end] [mates] [mymate] type=constpoisson params=1.0 1.0e1 [end] [end] [bcs] [fixleft] type=dirichlet dof=phi value=0.1 boundary=left [end] [fixright] type=dirichlet dof=phi value=0.5 boundary=right [end] [end] [job] type=static [end] You can also find the complete input file in examples/tutorial . If everything goes well, you can see the following image in your Paraview : Wait a minute, what should I do if I want to solve a Poisson equation in 3D? The answer is ...... quite simple, just change your mesh to 3D like this(the complete input file is step2-3d.i ): [mesh] type=asfem dim=3 nx=50 ny=50 nz=50 [end] then you will see:","title":"Step-2"},{"location":"Tutorial/step-2/#introduction","text":"In step-1 , our mesh was defined. Some necessary information, however, is still missing for a simple FEM analysis. Therefore, we will try to define our degrees of freedom (DoFs) in this step and also the element of our model. In the end, to obtain the final solution, we will apply the related boundary conditions.","title":"Introduction"},{"location":"Tutorial/step-2/#the-poisson-equation","text":"The issue we want to solve is the Poisson linear equation that reads as follows: $$ \\begin{equation} k\\nabla^{2}\\phi=F \\label{eq:poisson} \\tag{1} \\end{equation} $$ where \\(k\\) and \\(F\\) denote the model's coefficients. Below are the related boundary conditions: $$ \\begin{equation} k\\nabla\\phi\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:neumann} \\tag{2} \\end{equation} $$ and $$ \\begin{equation} \\phi=\\phi_{g}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D} \\label{eq:dirichlet} \\tag{3} \\end{equation} $$ where the Dirichlet boundary condition and Neumann boundary condition are defined by the subscripts \\(D\\) and \\(N\\) .","title":"The poisson equation"},{"location":"Tutorial/step-2/#define-the-degree-of-freedom-dof","text":"The degree of freedom (DoF) or the degrees of freedom (DoFs) can be used to define the name of each DoF and also to apply the necessary boundary conditions ( [bcs] ), elements ( [elmts] ), and so on. The [dofs] block looks like below: [dofs] name=dof1 dof2 dof3 ... [end]","title":"Define the degree of freedom (DoF)"},{"location":"Tutorial/step-2/#options","text":"The name= option specifies the name of each DoF. One should keep in mind that, the order of the name indicates the index of each DoFs. For instance, we need two displacements, namely disp_x and disp_y , if we want to do a 2D elastic analysis. The block of [dofs] should therefore be specified as: [dofs] name=disp_x disp_y [end] where disp_x is the first DoF(index=1), disp_y is the second DoF(index=2). That's all, name= is the only option in [dofs] block, nothing else. For the Poisson equation, because there is only one DoF involved, the final expression of [dofs] should be: [dofs] name=phi [end]","title":"Options"},{"location":"Tutorial/step-2/#element-for-poisson-equation","text":"The DoF is ready now, but the model in Eq. \\(\\eqref{eq:poisson}\\) is still missing. Thereby, we introduce the [elmts] block for this purpose. This block looks like below: [elmts] [elmt1] type=poisson dofs=phi mate=mymate [end] [end] where type= option specifies the element we want to use, it could be either the built-in elements of AsFem or the user-defined-element ( UEL ). The DoFs that will be used in this element are defined by dofs= . mate= gives the name of the material block that we want to use. Once the [elmts] block is given, the model we defined in Eq. \\(\\eqref{eq:poisson}\\) is ready.","title":"Element for Poisson equation"},{"location":"Tutorial/step-2/#material-properties","text":"For the coefficients \\(k\\) and \\(F\\) , namely the material properties, they can be calculated or defined via the [mates] block as follows: [mates] [mymate] type=constpoisson params=1.0 1.0e1 [end] [end] where type= specifies the material type name defined in AsFem. params= defines the parameters we want to use in our model, in this case, \\(k=1.0\\) and \\(F=10.0\\) will be used.","title":"Material properties"},{"location":"Tutorial/step-2/#boundary-conditions","text":"The boundary conditions, as mentioned in Eq. \\(\\eqref{eq:dirichlet}\\) and \\(\\eqref{eq:neumann}\\) , can be applied via the [bcs] block. In our case, the Neumann boundary condition in Eq. \\(\\eqref{eq:neumann}\\) is zero, therefore, only the Dirichlet boundary condition need to be considered: [bcs] [fixleft] type=dirichlet dof=phi value=0.1 boundary=left [end] [fixright] type=dirichlet dof=phi value=0.5 boundary=right [end] [end] where type= specifies the different types of boundary conditions supported by AsFem. dof= denotes the name of DoF we want to apply the given boundary conditions. In our case, we constrain the value of \\(\\phi\\) on the left and right side of a rectangle domain to be 0.1 and 0.5, respectively.","title":"Boundary conditions"},{"location":"Tutorial/step-2/#static-analysis","text":"Until now, all the model and boundary conditions are ready. To start the FEM calculation, we need a [job] block to tell AsFem which kind of analysis we want. For the static analysis in this case, it can be given as follows: [job] type=static [end] if one wants to see how the iteration information changes, one can use: [job] type=static debug=dep [end] where debug= option enables some basic information output in your terminal. If you don't want to see too many outputs, then you can use debug=false .","title":"Static analysis"},{"location":"Tutorial/step-2/#run-it-in-asfem","text":"Now, let's try your second example in AsFem. You can create a new text file and name it as step2.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 nx=50 ny=50 meshtype=quad4 [end] [dofs] name=phi [end] [elmts] [elmt1] type=poisson dofs=phi mate=mymate [end] [end] [mates] [mymate] type=constpoisson params=1.0 1.0e1 [end] [end] [bcs] [fixleft] type=dirichlet dof=phi value=0.1 boundary=left [end] [fixright] type=dirichlet dof=phi value=0.5 boundary=right [end] [end] [job] type=static [end] You can also find the complete input file in examples/tutorial . If everything goes well, you can see the following image in your Paraview : Wait a minute, what should I do if I want to solve a Poisson equation in 3D? The answer is ...... quite simple, just change your mesh to 3D like this(the complete input file is step2-3d.i ): [mesh] type=asfem dim=3 nx=50 ny=50 nz=50 [end] then you will see:","title":"Run it in AsFem"},{"location":"Tutorial/step-3/","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"],"text":"Introduction In this step, we will try to solve the linear elasticity problem. The stress equilibrium equation The problem we want to solve is the equation of stress equilibrium that reads as follows: $$ \\begin{equation} \\mathbf{\\nabla}\\cdot\\mathbf{\\sigma}=\\mathbf{0} \\label{eq:stress-eq} \\tag{1} \\end{equation} $$ where \\(\\mathbf{\\sigma}\\) denotes Cauchy stress tensor. The constitutive laws for the stress and strain of the small deformation case are below: $$ \\begin{equation} \\mathbf{\\sigma}=\\mathbb{C}:\\mathbf{\\epsilon} \\label{eq:stress} \\tag{2} \\end{equation} $$ and $$ \\begin{equation} \\mathbf{\\epsilon}=\\frac{1}{2}(\\nabla\\mathbf{u}+\\nabla \\mathbf{u}^{T}) \\label{eq:dirichlet} \\tag{3} \\end{equation} $$ where \\(\\mathbf{u}\\) is the displacement vector. \\(\\mathbb{C}\\) represents the elasticity tensor, which is a function of the Youngs modulus \\(E\\) and Poisson ratio \\(\\nu\\) . The related boundary conditions can be read as: $$ \\begin{equation} \\mathbf{t}\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:traction} \\tag{4} \\end{equation} $$ and $$ \\begin{equation} \\mathbf{u}=\\mathbf{u}_{0}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D} \\label{eq:disp} \\tag{5} \\end{equation} $$ where the traction free condition is assumed in Eq. \\(\\eqref{eq:traction}\\) Define a mesh For our calculation, we use a rectangular domain here, and then the [mesh] block can be given as: [mesh] type=asfem dim=2 xmax=5.0 ymax=5.0 nx=50 ny=50 meshtype=quad4 [end] where a \\(50\\times50\\) mesh is defined. Define the DoFs The DoFs used in this step is the displacement vector, namely \\(u_{x}\\) and \\(u_{y}\\) . Then the [dofs] block can be read as: [dofs] name=ux uy [end] Element for stress equilibrium equation The model in Eq. \\(\\eqref{eq:stress-eq}\\) can be applied in the following lines [elmts] [mysolid] type=mechanics dofs=ux uy mate=mymate [end] [end] where type=mechanics option specifies the element we want to use for solid mechanics problem. Moreover, we will use the linear elasticity material property, therefore, the related material definition will be given in mymate block. Linear elasticity material Via the following lines in your [mates] block, the linear elasticity material can be easily defined: [mates] [mymate] type=linearelastic params=210.0 0.3 [end] [end] where type=linearelastic specifies linear elasticity material type. params= defines the Youngs modulus ( \\(E=210GPa\\) ) and Poisson ratio ( \\(\\nu=0.3\\) ) Boundary conditions The boundary conditions, as mentioned in Eq. \\(\\eqref{eq:disp}\\) , can be applied via the [bcs] block. In our case, the traction boundary condition in Eq. \\(\\eqref{eq:traction}\\) is zero, therefore, only the displacement boundary condition needs to be considered: [bcs] [fixbottomX] type=dirichlet dof=ux value=0.0 boundary=bottom [end] [fixbottomY] type=dirichlet dof=uy value=0.0 boundary=bottom [end] [loadY] type=dirichlet dof=uy value=0.1 boundary=top [end] [end] where we fix the \\(u_{x}\\) and \\(u_{y}\\) to be zero at the bottom edge. While \\(u_{y}=0.1\\) is applied at the top edge of the domain. Static analysis Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=static debug=dep [end] Projection Wait for a minute, where are the stresses and strain? How can I output them? Noooo worries, the [projection] block can help you to project the quantities on each Gauss point to the Nodal point of your mesh. So, if we want to check how the vonMises stress, \\(\\sigma_{xx}\\) , \\(\\sigma_{yy}\\) , \\(\\sigma_{xy}\\) looks like, we can use: [projection] name=vonMises stress_xx stress_yy stress_xy [end] Done! Explanation of projection There is no magic for [projection] block, if you take a look at our MechanicsElmt.cpp in the ElmtSystem class, you will find the following code: gpProj[0]=ScalarMaterials.at(\"vonMises\"); gpProj[1]=Rank2Materials.at(\"stress\")(1,1);//sigma_xx if(nDim==2){ gpProj[2]=Rank2Materials.at(\"stress\")(2,2);//sigma_yy gpProj[3]=Rank2Materials.at(\"stress\")(1,2);//sigma_xy gpProj[4]=Rank2Materials.at(\"strain\")(1,1);//epsilon_xx gpProj[5]=Rank2Materials.at(\"strain\")(2,2);//epsilon_yy gpProj[6]=Rank2Materials.at(\"strain\")(1,2);//epsilon_xy } else if(nDim==3){ gpProj[2]=Rank2Materials.at(\"stress\")(2,2);//sigma_yy gpProj[3]=Rank2Materials.at(\"stress\")(3,3);//sigma_zz gpProj[4]=Rank2Materials.at(\"stress\")(2,3);//sigma_yz gpProj[5]=Rank2Materials.at(\"stress\")(1,3);//sigma_xz gpProj[6]=Rank2Materials.at(\"stress\")(1,2);//sigma_xy gpProj[7] =Rank2Materials.at(\"strain\")(1,1);//epsilon_xx gpProj[8] =Rank2Materials.at(\"strain\")(2,2);//epsilon_yy gpProj[9] =Rank2Materials.at(\"strain\")(3,3);//epsilon_zz gpProj[10]=Rank2Materials.at(\"strain\")(2,3);//epsilon_yz gpProj[11]=Rank2Materials.at(\"strain\")(1,3);//epsilon_xz gpProj[12]=Rank2Materials.at(\"strain\")(1,2);//epsilon_xy } Yelp, the order of the name you give in your [projection] block is related to the gpProj quantities in your element. So, if you want to project the quantities in a 3D case, then you will need: [projection] name=vonMises stress_xx stress_yy stress_zz stress_yz stress_xz stress_xy [end] Hold on, where is my strain tensor in 2D case? Take it easy, here it is: [projection] name=vonMises stress_xx stress_yy stress_xy epsilon_xx epsilon_yy epsilon_xy [end] Done! Run it in AsFem Now, let's try your third example in AsFem. You can create a new text file and name it as step3.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=5.0 ymax=5.0 nx=50 ny=50 meshtype=quad4 [end] [dofs] name=ux uy [end] [elmts] [mysolid] type=mechanics dofs=ux uy mate=mymate [end] [end] [mates] [mymate] type=linearelastic params=210.0 0.3 [end] [end] [bcs] [fixbottomX] type=dirichlet dof=ux value=0.0 boundary=bottom [end] [fixbottomY] type=dirichlet dof=uy value=0.0 boundary=bottom [end] [loadY] type=dirichlet dof=uy value=0.1 boundary=top [end] [end] [projection] name=vonMises stress_xx stress_yy stress_xy [end] [job] type=static debug=dep [end] You can also find the complete input file in examples/tutorial/step3.i . If everything goes well, you can see the following image in your Paraview :","title":"Step-3"},{"location":"Tutorial/step-3/#introduction","text":"In this step, we will try to solve the linear elasticity problem.","title":"Introduction"},{"location":"Tutorial/step-3/#the-stress-equilibrium-equation","text":"The problem we want to solve is the equation of stress equilibrium that reads as follows: $$ \\begin{equation} \\mathbf{\\nabla}\\cdot\\mathbf{\\sigma}=\\mathbf{0} \\label{eq:stress-eq} \\tag{1} \\end{equation} $$ where \\(\\mathbf{\\sigma}\\) denotes Cauchy stress tensor. The constitutive laws for the stress and strain of the small deformation case are below: $$ \\begin{equation} \\mathbf{\\sigma}=\\mathbb{C}:\\mathbf{\\epsilon} \\label{eq:stress} \\tag{2} \\end{equation} $$ and $$ \\begin{equation} \\mathbf{\\epsilon}=\\frac{1}{2}(\\nabla\\mathbf{u}+\\nabla \\mathbf{u}^{T}) \\label{eq:dirichlet} \\tag{3} \\end{equation} $$ where \\(\\mathbf{u}\\) is the displacement vector. \\(\\mathbb{C}\\) represents the elasticity tensor, which is a function of the Youngs modulus \\(E\\) and Poisson ratio \\(\\nu\\) . The related boundary conditions can be read as: $$ \\begin{equation} \\mathbf{t}\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:traction} \\tag{4} \\end{equation} $$ and $$ \\begin{equation} \\mathbf{u}=\\mathbf{u}_{0}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D} \\label{eq:disp} \\tag{5} \\end{equation} $$ where the traction free condition is assumed in Eq. \\(\\eqref{eq:traction}\\)","title":"The stress equilibrium equation"},{"location":"Tutorial/step-3/#define-a-mesh","text":"For our calculation, we use a rectangular domain here, and then the [mesh] block can be given as: [mesh] type=asfem dim=2 xmax=5.0 ymax=5.0 nx=50 ny=50 meshtype=quad4 [end] where a \\(50\\times50\\) mesh is defined.","title":"Define a mesh"},{"location":"Tutorial/step-3/#define-the-dofs","text":"The DoFs used in this step is the displacement vector, namely \\(u_{x}\\) and \\(u_{y}\\) . Then the [dofs] block can be read as: [dofs] name=ux uy [end]","title":"Define the DoFs"},{"location":"Tutorial/step-3/#element-for-stress-equilibrium-equation","text":"The model in Eq. \\(\\eqref{eq:stress-eq}\\) can be applied in the following lines [elmts] [mysolid] type=mechanics dofs=ux uy mate=mymate [end] [end] where type=mechanics option specifies the element we want to use for solid mechanics problem. Moreover, we will use the linear elasticity material property, therefore, the related material definition will be given in mymate block.","title":"Element for stress equilibrium equation"},{"location":"Tutorial/step-3/#linear-elasticity-material","text":"Via the following lines in your [mates] block, the linear elasticity material can be easily defined: [mates] [mymate] type=linearelastic params=210.0 0.3 [end] [end] where type=linearelastic specifies linear elasticity material type. params= defines the Youngs modulus ( \\(E=210GPa\\) ) and Poisson ratio ( \\(\\nu=0.3\\) )","title":"Linear elasticity material"},{"location":"Tutorial/step-3/#boundary-conditions","text":"The boundary conditions, as mentioned in Eq. \\(\\eqref{eq:disp}\\) , can be applied via the [bcs] block. In our case, the traction boundary condition in Eq. \\(\\eqref{eq:traction}\\) is zero, therefore, only the displacement boundary condition needs to be considered: [bcs] [fixbottomX] type=dirichlet dof=ux value=0.0 boundary=bottom [end] [fixbottomY] type=dirichlet dof=uy value=0.0 boundary=bottom [end] [loadY] type=dirichlet dof=uy value=0.1 boundary=top [end] [end] where we fix the \\(u_{x}\\) and \\(u_{y}\\) to be zero at the bottom edge. While \\(u_{y}=0.1\\) is applied at the top edge of the domain.","title":"Boundary conditions"},{"location":"Tutorial/step-3/#static-analysis","text":"Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=static debug=dep [end]","title":"Static analysis"},{"location":"Tutorial/step-3/#projection","text":"Wait for a minute, where are the stresses and strain? How can I output them? Noooo worries, the [projection] block can help you to project the quantities on each Gauss point to the Nodal point of your mesh. So, if we want to check how the vonMises stress, \\(\\sigma_{xx}\\) , \\(\\sigma_{yy}\\) , \\(\\sigma_{xy}\\) looks like, we can use: [projection] name=vonMises stress_xx stress_yy stress_xy [end] Done!","title":"Projection"},{"location":"Tutorial/step-3/#explanation-of-projection","text":"There is no magic for [projection] block, if you take a look at our MechanicsElmt.cpp in the ElmtSystem class, you will find the following code: gpProj[0]=ScalarMaterials.at(\"vonMises\"); gpProj[1]=Rank2Materials.at(\"stress\")(1,1);//sigma_xx if(nDim==2){ gpProj[2]=Rank2Materials.at(\"stress\")(2,2);//sigma_yy gpProj[3]=Rank2Materials.at(\"stress\")(1,2);//sigma_xy gpProj[4]=Rank2Materials.at(\"strain\")(1,1);//epsilon_xx gpProj[5]=Rank2Materials.at(\"strain\")(2,2);//epsilon_yy gpProj[6]=Rank2Materials.at(\"strain\")(1,2);//epsilon_xy } else if(nDim==3){ gpProj[2]=Rank2Materials.at(\"stress\")(2,2);//sigma_yy gpProj[3]=Rank2Materials.at(\"stress\")(3,3);//sigma_zz gpProj[4]=Rank2Materials.at(\"stress\")(2,3);//sigma_yz gpProj[5]=Rank2Materials.at(\"stress\")(1,3);//sigma_xz gpProj[6]=Rank2Materials.at(\"stress\")(1,2);//sigma_xy gpProj[7] =Rank2Materials.at(\"strain\")(1,1);//epsilon_xx gpProj[8] =Rank2Materials.at(\"strain\")(2,2);//epsilon_yy gpProj[9] =Rank2Materials.at(\"strain\")(3,3);//epsilon_zz gpProj[10]=Rank2Materials.at(\"strain\")(2,3);//epsilon_yz gpProj[11]=Rank2Materials.at(\"strain\")(1,3);//epsilon_xz gpProj[12]=Rank2Materials.at(\"strain\")(1,2);//epsilon_xy } Yelp, the order of the name you give in your [projection] block is related to the gpProj quantities in your element. So, if you want to project the quantities in a 3D case, then you will need: [projection] name=vonMises stress_xx stress_yy stress_zz stress_yz stress_xz stress_xy [end] Hold on, where is my strain tensor in 2D case? Take it easy, here it is: [projection] name=vonMises stress_xx stress_yy stress_xy epsilon_xx epsilon_yy epsilon_xy [end] Done!","title":"Explanation of projection"},{"location":"Tutorial/step-3/#run-it-in-asfem","text":"Now, let's try your third example in AsFem. You can create a new text file and name it as step3.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=5.0 ymax=5.0 nx=50 ny=50 meshtype=quad4 [end] [dofs] name=ux uy [end] [elmts] [mysolid] type=mechanics dofs=ux uy mate=mymate [end] [end] [mates] [mymate] type=linearelastic params=210.0 0.3 [end] [end] [bcs] [fixbottomX] type=dirichlet dof=ux value=0.0 boundary=bottom [end] [fixbottomY] type=dirichlet dof=uy value=0.0 boundary=bottom [end] [loadY] type=dirichlet dof=uy value=0.1 boundary=top [end] [end] [projection] name=vonMises stress_xx stress_yy stress_xy [end] [job] type=static debug=dep [end] You can also find the complete input file in examples/tutorial/step3.i . If everything goes well, you can see the following image in your Paraview :","title":"Run it in AsFem"},{"location":"Tutorial/step-4/","tags":["tutorial","input file","mesh","dofs","elmts","mates","diffusion","timestepping"],"text":"Introduction In this step, we will try to solve the linear diffusion problem. The diffusion equation The problem we want to solve is the diffusion equation that reads as follows: $$ \\begin{equation} \\frac{\\partial c}{\\partial t}=\\nabla\\cdot(D\\nabla c) \\label{eq:diffusion-eq} \\tag{1} \\end{equation} $$ where \\(c\\) denotes the concentration of the species. \\(D\\) is the diffusion coefficient The related boundary conditions can be read as: $$ \\begin{equation} -D\\nabla c\\cdot\\vec{n}=-0.5\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:flux} \\tag{2} \\end{equation} $$ where the flux ( Neumann ) boundary condition is assumed in Eq. \\(\\eqref{eq:flux}\\) . Define the mesh For our calculation, we use a cubic domain here, and then the [mesh] block can be given as: [mesh] type=asfem dim=3 xmax=1.0 ymax=1.0 zmax=10.0 nx=5 ny=5 nz=50 meshtype=hex8 [end] where a \\(1\\times1\\times10\\) mesh is defined. Define the DoFs The DoFs used in this step is the concentration, namely \\(c\\) . Then the [dofs] block can be read as: [dofs] name=c [end] Element for the diffusion equation The model in Eq. \\(\\eqref{eq:diffusion-eq}\\) can be applied in the following lines [elmts] [mydiffusion] type=diffusion dofs=c mate=mymate [end] [end] where type=diffusion option specifies the element we want to use for the diffusion problem. Moreover, we will use the constant diffusivity material property, therefore, the related material definition will be given in mymate block. Constant diffusivity material property Via the following lines in your [mates] block, the constant diffusivity \\(D\\) can be easily defined: [mates] [mymate] type=constdiffusion params=1.0e1 [end] [end] where type=constdiffusion specifies constant diffusivity material type. params= defines the diffusivity \\(D\\) ( \\(D=10.0\\) ). Boundary conditions The boundary conditions, as mentioned in Eq. \\(\\eqref{eq:flux}\\) , can be applied via the [bcs] block. In our case, only the flux boundary ( Neumann ) condition needs to be considered: [bcs] [flux] type=neumann dof=c value=-0.5 boundary=front [end] [end] where we apply a constant flux to the front surface of our cubic domain. Transient analysis Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=transient debug=dep [end] Timestepping Wait for a minute, where are the settings for the transient analysis, for instance the initial \\(\\Delta_t\\) and the final time? Noooo worries, the [timestepping] block can help you to set the different time stepping method as well as the \\(\\Delta_t\\) , \\(T_{\\mathrm{final}}\\) stuffs. The layout of this block looks like below: [timestepping] type=be dt=1.0e-3 time=1.0e0 [end] where type=be specifies the Backward-Euler (be) method for implicit time integration. It should be mentioned that, AsFem only support the implicit method, the explicit method like Forward-Euler (fe) is not supported! dt=1.0e-3 defines that the initial \\(\\Delta_{t}\\) is \\(10^{-3}\\) , while time=1.0e0 means the final time is 1.0. Done! Run it in AsFem Now, let's try your fourth example in AsFem. You can create a new text file and name it as step3.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=3 xmax=1.0 ymax=1.0 zmax=10.0 nx=5 ny=5 nz=50 meshtype=hex8 [end] [dofs] name=c [end] [elmts] [mydiffusion] type=diffusion dofs=c mate=mymate [end] [end] [mates] [mymate] type=constdiffusion params=1.0e1 [end] [end] [bcs] [flux] type=neumann dof=c value=-0.5 boundary=front [end] [end] [timestepping] type=be dt=1.0e-3 time=1.0e0 [end] [job] type=transient debug=dep [end] You can also find the complete input file in examples/tutorial/step4.i . If everything goes well, you can see the following image in your Paraview : The outputs You may see the following outputs from your terminal: ***-----------------------------------------------------------------------*** *** SNES solver:iters= 0,|R|= 1.4306e-02,|dU|= 3.0700e+00,dt=1.00e-03 *** *** SNES solver:iters= 1,|R|= 1.3957e-15,|dU|= 2.4301e-03,dt=1.00e-03 *** *** Time step= 999, time= 9.99000e-01, dt= 1.00000e-03 *** *** Write result to step4-00000999.vtu *** ***-----------------------------------------------------------------------*** *** SNES solver:iters= 0,|R|= 1.4303e-02,|dU|= 3.0723e+00,dt=1.00e-03 *** *** SNES solver:iters= 1,|R|= 1.3530e-15,|dU|= 2.4296e-03,dt=1.00e-03 *** *** Time step= 1000, time= 1.00000e+00, dt= 1.00000e-03 *** *** Write result to step4-00001000.vtu *** ***-----------------------------------------------------------------------*** *** Time step= -1, time= 1.00000e+00, dt= 1.00000e-03 *** *** Write result to step4-000000-1.vtu *** ***-----------------------------------------------------------------------*** One can see that, when the current time \\(t\\) reaches \\(1.0\\) , the related output file name is step4-00001000.vtu (for the 1000-th step). Moreover, AsFem will also give the final output step4-000000-1.vtu , which could be very helpful when \\(t_{\\mathrm{old}}+\\Delta_{t}>T_{\\mathrm{final}}\\) .","title":"Step-4"},{"location":"Tutorial/step-4/#introduction","text":"In this step, we will try to solve the linear diffusion problem.","title":"Introduction"},{"location":"Tutorial/step-4/#the-diffusion-equation","text":"The problem we want to solve is the diffusion equation that reads as follows: $$ \\begin{equation} \\frac{\\partial c}{\\partial t}=\\nabla\\cdot(D\\nabla c) \\label{eq:diffusion-eq} \\tag{1} \\end{equation} $$ where \\(c\\) denotes the concentration of the species. \\(D\\) is the diffusion coefficient The related boundary conditions can be read as: $$ \\begin{equation} -D\\nabla c\\cdot\\vec{n}=-0.5\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:flux} \\tag{2} \\end{equation} $$ where the flux ( Neumann ) boundary condition is assumed in Eq. \\(\\eqref{eq:flux}\\) .","title":"The diffusion equation"},{"location":"Tutorial/step-4/#define-the-mesh","text":"For our calculation, we use a cubic domain here, and then the [mesh] block can be given as: [mesh] type=asfem dim=3 xmax=1.0 ymax=1.0 zmax=10.0 nx=5 ny=5 nz=50 meshtype=hex8 [end] where a \\(1\\times1\\times10\\) mesh is defined.","title":"Define the mesh"},{"location":"Tutorial/step-4/#define-the-dofs","text":"The DoFs used in this step is the concentration, namely \\(c\\) . Then the [dofs] block can be read as: [dofs] name=c [end]","title":"Define the DoFs"},{"location":"Tutorial/step-4/#element-for-the-diffusion-equation","text":"The model in Eq. \\(\\eqref{eq:diffusion-eq}\\) can be applied in the following lines [elmts] [mydiffusion] type=diffusion dofs=c mate=mymate [end] [end] where type=diffusion option specifies the element we want to use for the diffusion problem. Moreover, we will use the constant diffusivity material property, therefore, the related material definition will be given in mymate block.","title":"Element for the diffusion equation"},{"location":"Tutorial/step-4/#constant-diffusivity-material-property","text":"Via the following lines in your [mates] block, the constant diffusivity \\(D\\) can be easily defined: [mates] [mymate] type=constdiffusion params=1.0e1 [end] [end] where type=constdiffusion specifies constant diffusivity material type. params= defines the diffusivity \\(D\\) ( \\(D=10.0\\) ).","title":"Constant diffusivity material property"},{"location":"Tutorial/step-4/#boundary-conditions","text":"The boundary conditions, as mentioned in Eq. \\(\\eqref{eq:flux}\\) , can be applied via the [bcs] block. In our case, only the flux boundary ( Neumann ) condition needs to be considered: [bcs] [flux] type=neumann dof=c value=-0.5 boundary=front [end] [end] where we apply a constant flux to the front surface of our cubic domain.","title":"Boundary conditions"},{"location":"Tutorial/step-4/#transient-analysis","text":"Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=transient debug=dep [end]","title":"Transient analysis"},{"location":"Tutorial/step-4/#timestepping","text":"Wait for a minute, where are the settings for the transient analysis, for instance the initial \\(\\Delta_t\\) and the final time? Noooo worries, the [timestepping] block can help you to set the different time stepping method as well as the \\(\\Delta_t\\) , \\(T_{\\mathrm{final}}\\) stuffs. The layout of this block looks like below: [timestepping] type=be dt=1.0e-3 time=1.0e0 [end] where type=be specifies the Backward-Euler (be) method for implicit time integration. It should be mentioned that, AsFem only support the implicit method, the explicit method like Forward-Euler (fe) is not supported! dt=1.0e-3 defines that the initial \\(\\Delta_{t}\\) is \\(10^{-3}\\) , while time=1.0e0 means the final time is 1.0. Done!","title":"Timestepping"},{"location":"Tutorial/step-4/#run-it-in-asfem","text":"Now, let's try your fourth example in AsFem. You can create a new text file and name it as step3.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=3 xmax=1.0 ymax=1.0 zmax=10.0 nx=5 ny=5 nz=50 meshtype=hex8 [end] [dofs] name=c [end] [elmts] [mydiffusion] type=diffusion dofs=c mate=mymate [end] [end] [mates] [mymate] type=constdiffusion params=1.0e1 [end] [end] [bcs] [flux] type=neumann dof=c value=-0.5 boundary=front [end] [end] [timestepping] type=be dt=1.0e-3 time=1.0e0 [end] [job] type=transient debug=dep [end] You can also find the complete input file in examples/tutorial/step4.i . If everything goes well, you can see the following image in your Paraview :","title":"Run it in AsFem"},{"location":"Tutorial/step-4/#the-outputs","text":"You may see the following outputs from your terminal: ***-----------------------------------------------------------------------*** *** SNES solver:iters= 0,|R|= 1.4306e-02,|dU|= 3.0700e+00,dt=1.00e-03 *** *** SNES solver:iters= 1,|R|= 1.3957e-15,|dU|= 2.4301e-03,dt=1.00e-03 *** *** Time step= 999, time= 9.99000e-01, dt= 1.00000e-03 *** *** Write result to step4-00000999.vtu *** ***-----------------------------------------------------------------------*** *** SNES solver:iters= 0,|R|= 1.4303e-02,|dU|= 3.0723e+00,dt=1.00e-03 *** *** SNES solver:iters= 1,|R|= 1.3530e-15,|dU|= 2.4296e-03,dt=1.00e-03 *** *** Time step= 1000, time= 1.00000e+00, dt= 1.00000e-03 *** *** Write result to step4-00001000.vtu *** ***-----------------------------------------------------------------------*** *** Time step= -1, time= 1.00000e+00, dt= 1.00000e-03 *** *** Write result to step4-000000-1.vtu *** ***-----------------------------------------------------------------------*** One can see that, when the current time \\(t\\) reaches \\(1.0\\) , the related output file name is step4-00001000.vtu (for the 1000-th step). Moreover, AsFem will also give the final output step4-000000-1.vtu , which could be very helpful when \\(t_{\\mathrm{old}}+\\Delta_{t}>T_{\\mathrm{final}}\\) .","title":"The outputs"},{"location":"Tutorial/step-5/","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"],"text":"Introduction In this step, we will try to solve the CahnHilliard equation for the spinodal decomposition problem. The CahnHilliard equation The CahnHilliard equation can be read as follows: $$ \\begin{equation} \\frac{\\partial c}{\\partial t}=\\nabla\\cdot(M(c)\\nabla\\mu) \\label{eq:ch-c} \\tag{1} \\end{equation} $$ and $$ \\begin{equation} \\mu=\\frac{\\delta f}{\\delta c} \\label{eq:ch-mu} \\tag{2} \\end{equation} $$ where \\(c\\) and \\(\\mu\\) denote the concentration and chemical potential, respectively. \\(M(c)\\) is the concentration dependent mobility, in this model we use \\(M(c)=Dc(1-c)\\) , where \\(D\\) is the diffusion coefficient. Free energy In this model, we use the following free energy: $$ \\begin{equation} f=c\\ln(c)+(1-c)\\ln(1-c)+\\chi c(1-c)+\\kappa|\\nabla c|^{2} \\label{eq:free-energy} \\tag{3} \\end{equation} $$ thereby, the chemical potential \\(\\mu\\) can be expressed as: $$ \\begin{equation} \\mu=\\ln(c)-\\ln(1-c)+\\chi(1-c)-\\kappa\\nabla^{2}c \\label{eq:mu} \\tag{4} \\end{equation} $$ where \\(\\chi\\) denotes the interaction between two phases. \\(\\kappa\\) represents the interface energy contribution, which is proportional to the thickness of the phase interface. The related boundary conditions can be read as: $$ \\begin{equation} -D\\nabla c\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:flux} \\tag{5} \\end{equation} $$ where the zero flux ( Neumann ) boundary condition is assumed in Eq. \\(\\eqref{eq:flux}\\) . Define the mesh We use a square domain here for our calculation, and then the [mesh] block can be given as: [mesh] type=asfem dim=2 xmax=4.0 ymax=4.0 nx=100 ny=100 meshtype=quad4 [end] where a \\(4\\times4\\) mesh is defined. Gauss point integration (optional) If one wants to use second order mesh, for instance meshtype=quad9 , then one need to use a higher order gauss points. This can be implemented via: [qpoint] type=gauss order=3 [end] Normally, you don't need this block! Define the DoFs In order to solve the 4th order equation, we split the CH equation into two second-order equations. Therefore, the DoFs used in this step are the concentration \\(c\\) and the chemical potential \\(\\mu\\) . Then the [dofs] block can be read as: [dofs] name=c mu [end] Element for the CahnHilliard equation The model in Eq. \\(\\eqref{eq:ch-c}\\) and \\(\\eqref{eq:ch-mu}\\) can be applied in the following lines [elmts] [mych] type=cahnhilliard dofs=c mu mate=myf [end] [end] where type=cahnhilliard option specifies the element we want to use for the CahnHilliard equation. Moreover, we will use the free energy ( \\(F\\) ), the first order derivative of free energy( \\(\\frac{\\partial F}{\\partial c}\\) ), and the second order derivative of free energy( \\(\\frac{\\partial^{2}f}{\\partial c^{2}}\\) ) material properties. Therefore, the related material definition will be given in myf block. free energy material Via the following lines in your [mates] block, the material properties, i.e. \\(F\\) , \\(\\frac{\\partial F}{\\partial c}\\) , and \\(\\frac{\\partial^{2}F}{\\partial c^{2}}\\) can be easily defined: [mates] [myf] type=cahnhilliard params=1.0 2.5 0.005 [end] [end] where type=cahnhilliard specifies constant diffusivity material type. Don't worry, here we used the same name as the type= in [elmts] block. But AsFem knows that they belong to two different blocks, so it's fine. params= defines the diffusivity \\(D=1.0\\) , the phase interaction constant \\(\\chi=2.5\\) , and the interface parameter \\(\\kappa=0.02\\) . If you are using a coarse mesh, please increase \\(\\kappa\\) to a larger value, i.e. 0.02 or even higher. Boundary conditions Since the zero flux boundary condition is applied, we don't need any [bcs] block. If Eq. \\(\\eqref{eq:flux}\\) is nonzero, then you will definitely need the [bcs] block. Transient analysis Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=transient debug=dep [end] Timestepping In this case, we will use the adaptive time stepping to speed up our simulation. The layout of our [timestepping] block looks like below: [timestepping] type=be dt=1.0e-5 time=1.0e3 adaptive=true optiters=3 growthfactor=1.1 cutfactor=0.85 [end] where type=be specifies the Backward-Euler (be) method for implicit time integration. dt=1.0e-5 defines that the initial \\(\\Delta_{t}\\) and time=1.0e3 means the final time is 1000.0. adaptive=true enables the adaptive time stepping. optiters=3 indicates that if the nonlinear iterations is not greater than 3, then AsFem will increase the new delta t to be \\(\\Delta_{t}=\\Delta_{t,\\mathrm{old}}*\\alpha_{\\mathrm{growth}}\\) . Otherwise, the new delta t will be reduced as \\(\\Delta_{t}=\\Delta_{t,\\mathrm{old}}*\\alpha_{\\mathrm{cut}}\\) . growthfactor and cutfactor represent \\(\\alpha_{\\mathrm{growth}}\\) and \\(\\alpha_{\\mathrm{cut}}\\) , respectively. Initial condition Now, in order to allow the phase separation to take place, we must add the random value to the concentration. As follows, the random concentration value can be applied through the'[ics]' block: [ics] [ic1] type=random dof=c params=0.6 0.66 [end] [end] where the random value is applied via the type=random option. dof= indicates which DoF will be used. params= represent the parameters used in the initial condition calculation. For the type=random case, 0.6 and 0.66 are the min and max value of the random numbers. Parallel solver In order to further speed up our simulation, we involve the parallel solver from either mumps or superlu_dist . This can be defined via the [nonlinearsolver] block: [nonlinearsolver] type=nr solver=superlu [end] where type=nr indicates the newton-raphson method. solver= determines the name of the parallel solver, in this case, the superlu_dist solver is used. It should be noted that, if external solvers, i.e. mumps and superlu , are not compiled within your PETSc, then you can only use the built-in solver. In short, this option doesn\u2019t make sense to you. Run it in AsFem Now, let's try your fourth example in AsFem. You can create a new text file and name it as step5.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=4.0 ymax=4.0 nx=100 ny=100 meshtype=quad4 [end] [dofs] name=c mu [end] [elmts] [mych] type=cahnhilliard dofs=c mu mate=myf [end] [end] [mates] [myf] type=cahnhilliard params=1.0 2.5 0.005 // D Chi Kappa [end] [end] [timestepping] type=be dt=1.0e-5 time=3.0e3 adaptive=true optiters=3 growthfactor=1.1 cutfactor=0.85 [end] [nonlinearsolver] type=nr solver=superlu [end] [ics] [ic1] type=random dof=c params=0.6 0.66 [end] [end] [job] type=transient debug=dep [end] You can also find the complete input file in examples/tutorial/step5.i . If everything goes well, you can see the following image in your Paraview :","title":"Step-5"},{"location":"Tutorial/step-5/#introduction","text":"In this step, we will try to solve the CahnHilliard equation for the spinodal decomposition problem.","title":"Introduction"},{"location":"Tutorial/step-5/#the-cahnhilliard-equation","text":"The CahnHilliard equation can be read as follows: $$ \\begin{equation} \\frac{\\partial c}{\\partial t}=\\nabla\\cdot(M(c)\\nabla\\mu) \\label{eq:ch-c} \\tag{1} \\end{equation} $$ and $$ \\begin{equation} \\mu=\\frac{\\delta f}{\\delta c} \\label{eq:ch-mu} \\tag{2} \\end{equation} $$ where \\(c\\) and \\(\\mu\\) denote the concentration and chemical potential, respectively. \\(M(c)\\) is the concentration dependent mobility, in this model we use \\(M(c)=Dc(1-c)\\) , where \\(D\\) is the diffusion coefficient.","title":"The CahnHilliard equation"},{"location":"Tutorial/step-5/#free-energy","text":"In this model, we use the following free energy: $$ \\begin{equation} f=c\\ln(c)+(1-c)\\ln(1-c)+\\chi c(1-c)+\\kappa|\\nabla c|^{2} \\label{eq:free-energy} \\tag{3} \\end{equation} $$ thereby, the chemical potential \\(\\mu\\) can be expressed as: $$ \\begin{equation} \\mu=\\ln(c)-\\ln(1-c)+\\chi(1-c)-\\kappa\\nabla^{2}c \\label{eq:mu} \\tag{4} \\end{equation} $$ where \\(\\chi\\) denotes the interaction between two phases. \\(\\kappa\\) represents the interface energy contribution, which is proportional to the thickness of the phase interface. The related boundary conditions can be read as: $$ \\begin{equation} -D\\nabla c\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:flux} \\tag{5} \\end{equation} $$ where the zero flux ( Neumann ) boundary condition is assumed in Eq. \\(\\eqref{eq:flux}\\) .","title":"Free energy"},{"location":"Tutorial/step-5/#define-the-mesh","text":"We use a square domain here for our calculation, and then the [mesh] block can be given as: [mesh] type=asfem dim=2 xmax=4.0 ymax=4.0 nx=100 ny=100 meshtype=quad4 [end] where a \\(4\\times4\\) mesh is defined.","title":"Define the mesh"},{"location":"Tutorial/step-5/#gauss-point-integration-optional","text":"If one wants to use second order mesh, for instance meshtype=quad9 , then one need to use a higher order gauss points. This can be implemented via: [qpoint] type=gauss order=3 [end] Normally, you don't need this block!","title":"Gauss point integration (optional)"},{"location":"Tutorial/step-5/#define-the-dofs","text":"In order to solve the 4th order equation, we split the CH equation into two second-order equations. Therefore, the DoFs used in this step are the concentration \\(c\\) and the chemical potential \\(\\mu\\) . Then the [dofs] block can be read as: [dofs] name=c mu [end]","title":"Define the DoFs"},{"location":"Tutorial/step-5/#element-for-the-cahnhilliard-equation","text":"The model in Eq. \\(\\eqref{eq:ch-c}\\) and \\(\\eqref{eq:ch-mu}\\) can be applied in the following lines [elmts] [mych] type=cahnhilliard dofs=c mu mate=myf [end] [end] where type=cahnhilliard option specifies the element we want to use for the CahnHilliard equation. Moreover, we will use the free energy ( \\(F\\) ), the first order derivative of free energy( \\(\\frac{\\partial F}{\\partial c}\\) ), and the second order derivative of free energy( \\(\\frac{\\partial^{2}f}{\\partial c^{2}}\\) ) material properties. Therefore, the related material definition will be given in myf block.","title":"Element for the CahnHilliard equation"},{"location":"Tutorial/step-5/#free-energy-material","text":"Via the following lines in your [mates] block, the material properties, i.e. \\(F\\) , \\(\\frac{\\partial F}{\\partial c}\\) , and \\(\\frac{\\partial^{2}F}{\\partial c^{2}}\\) can be easily defined: [mates] [myf] type=cahnhilliard params=1.0 2.5 0.005 [end] [end] where type=cahnhilliard specifies constant diffusivity material type. Don't worry, here we used the same name as the type= in [elmts] block. But AsFem knows that they belong to two different blocks, so it's fine. params= defines the diffusivity \\(D=1.0\\) , the phase interaction constant \\(\\chi=2.5\\) , and the interface parameter \\(\\kappa=0.02\\) . If you are using a coarse mesh, please increase \\(\\kappa\\) to a larger value, i.e. 0.02 or even higher.","title":"free energy material"},{"location":"Tutorial/step-5/#boundary-conditions","text":"Since the zero flux boundary condition is applied, we don't need any [bcs] block. If Eq. \\(\\eqref{eq:flux}\\) is nonzero, then you will definitely need the [bcs] block.","title":"Boundary conditions"},{"location":"Tutorial/step-5/#transient-analysis","text":"Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=transient debug=dep [end]","title":"Transient analysis"},{"location":"Tutorial/step-5/#timestepping","text":"In this case, we will use the adaptive time stepping to speed up our simulation. The layout of our [timestepping] block looks like below: [timestepping] type=be dt=1.0e-5 time=1.0e3 adaptive=true optiters=3 growthfactor=1.1 cutfactor=0.85 [end] where type=be specifies the Backward-Euler (be) method for implicit time integration. dt=1.0e-5 defines that the initial \\(\\Delta_{t}\\) and time=1.0e3 means the final time is 1000.0. adaptive=true enables the adaptive time stepping. optiters=3 indicates that if the nonlinear iterations is not greater than 3, then AsFem will increase the new delta t to be \\(\\Delta_{t}=\\Delta_{t,\\mathrm{old}}*\\alpha_{\\mathrm{growth}}\\) . Otherwise, the new delta t will be reduced as \\(\\Delta_{t}=\\Delta_{t,\\mathrm{old}}*\\alpha_{\\mathrm{cut}}\\) . growthfactor and cutfactor represent \\(\\alpha_{\\mathrm{growth}}\\) and \\(\\alpha_{\\mathrm{cut}}\\) , respectively.","title":"Timestepping"},{"location":"Tutorial/step-5/#initial-condition","text":"Now, in order to allow the phase separation to take place, we must add the random value to the concentration. As follows, the random concentration value can be applied through the'[ics]' block: [ics] [ic1] type=random dof=c params=0.6 0.66 [end] [end] where the random value is applied via the type=random option. dof= indicates which DoF will be used. params= represent the parameters used in the initial condition calculation. For the type=random case, 0.6 and 0.66 are the min and max value of the random numbers.","title":"Initial condition"},{"location":"Tutorial/step-5/#parallel-solver","text":"In order to further speed up our simulation, we involve the parallel solver from either mumps or superlu_dist . This can be defined via the [nonlinearsolver] block: [nonlinearsolver] type=nr solver=superlu [end] where type=nr indicates the newton-raphson method. solver= determines the name of the parallel solver, in this case, the superlu_dist solver is used. It should be noted that, if external solvers, i.e. mumps and superlu , are not compiled within your PETSc, then you can only use the built-in solver. In short, this option doesn\u2019t make sense to you.","title":"Parallel solver"},{"location":"Tutorial/step-5/#run-it-in-asfem","text":"Now, let's try your fourth example in AsFem. You can create a new text file and name it as step5.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=4.0 ymax=4.0 nx=100 ny=100 meshtype=quad4 [end] [dofs] name=c mu [end] [elmts] [mych] type=cahnhilliard dofs=c mu mate=myf [end] [end] [mates] [myf] type=cahnhilliard params=1.0 2.5 0.005 // D Chi Kappa [end] [end] [timestepping] type=be dt=1.0e-5 time=3.0e3 adaptive=true optiters=3 growthfactor=1.1 cutfactor=0.85 [end] [nonlinearsolver] type=nr solver=superlu [end] [ics] [ic1] type=random dof=c params=0.6 0.66 [end] [end] [job] type=transient debug=dep [end] You can also find the complete input file in examples/tutorial/step5.i . If everything goes well, you can see the following image in your Paraview :","title":"Run it in AsFem"},{"location":"Tutorial/step-6/","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"],"text":"Introduction In this step, we will try to solve the linear momentum balance equation for the linear elastic problem. The linear momentum balance equation The equation can be read as follows: $$ \\begin{equation} \\rho\\frac{\\partial v}{\\partial t}=\\mathbf{\\nabla}\\cdot\\mathbf{\\sigma}+\\rho\\mathbf{b} \\label{eq:stress-equation} \\tag{1} \\end{equation} $$ with \\(\\rho\\) being the density, \\(\\mathbf{b}\\) denoting the body force (i.e., gravity), \\(\\mathbf{\\sigma}\\) being the Cauchy stress tensor. The boundary condition for this problem is defined as follows: $$ \\begin{equation} \\mathbf{u}=u_{g}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D}\\qquad\\qquad \\mathbf{\\sigma}\\cdot\\vec{n}=\\mathbf{t}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\end{equation} $$ Next, by using the weighted integration and integration by parts, one can obtain: $$ \\begin{equation} \\delta I[\\mathbf{u}]= \\int_{\\Omega}\\sigma_{ij}\\delta u_{i,j}dV -\\int_{\\Omega}\\rho b_{i}\\delta u_{i}dV -\\int_{\\partial\\Omega}t_{i}\\delta u_{i}dS=0 \\label{eq:weighted-integration} \\tag{2} \\end{equation} $$ then, the residual for \\(\\eqref{eq:weighted-integration}\\) can be expressed as follows: $$ \\begin{equation} R_{u_{i}}^{I}= \\int_{\\Omega}\\sigma_{ij}N_{,j}^{I}dV -\\int_{\\Omega}\\rho b_{i}N^{I}dV -\\int_{\\partial\\Omega_{N}}t_{i}N^{I}dS \\label{eq:residual} \\tag{3} \\end{equation} $$ where the \"acceleration\" term has been ignored. Then the related jacobian matrix can be given as follows: $$ \\begin{equation} K_{ik}^{IJ}=\\frac{\\partial R_{u_{i}}^{I}}{\\partial u_{k}^{J}} =\\int_{\\Omega}\\mathbb{C}_{ijkl} N_{,j}^{I}N_{,l}^{J}dV \\label{eq:jacobian} \\tag{4} \\end{equation} $$ where \\(\\mathbb{C}_{ijkl}\\) denotes the elasticity tensor. \\(I\\) and \\(J\\) respectively represent the I-th and J-th node of the current element. Constitutive laws For the small strain case, one can have $$ \\begin{equation} \\mathbf{\\varepsilon}=\\frac{1}{2}(\\nabla u+\\nabla^{T}u) \\label{eq:strain} \\tag{5} \\end{equation} $$ which can be easily calculated in AsFem as follows: if(elmtinfo.nDim==1){ _GradU.SetFromGradU(elmtsoln.gpGradU[1]); } else if(elmtinfo.nDim==2){ _GradU.SetFromGradU(elmtsoln.gpGradU[1],elmtsoln.gpGradU[2]); } else if(elmtinfo.nDim==3){ _GradU.SetFromGradU(elmtsoln.gpGradU[1],elmtsoln.gpGradU[2],elmtsoln.gpGradU[3]); } Strain=(_GradU+_GradU.Transpose())*0.5; For the linear elasticity tensor \\(\\mathbb{C}\\) , you need to give the Young's modulus and poisson ratio, then its value can be defined as follows: Jacobian.SetFromEandNu(E,nu); where AsFem offers the RankTwoTensor and RankFourTensor class for the complex tensor calculation. Next, once your strain \\(\\mathbf{\\varepsilon}\\) and elasticity tensor \\(\\mathbb{C}\\) are ready, you can easily get your stress tensor \\(\\mathbf{\\sigma}\\) as follows: Stress=Jacobian.DoubleDot(Strain); That's all? Yup, all the calculation is done. If I want to calculate the vonMises stress, what should I do? The answer is quite simple, here is the code RankTwoTensor I; I.SetToIdentity(); devStress=_Stress-_I*(_Stress.Trace()/3.0); Mate.ScalarMaterials(\"vonMises\")=sqrt(1.5*_devStress.DoubleDot(_devStress)); once again, the complex tensor calculation is done by our RankTwoTensor class. So, for a general mechanics problem, what you need to tell AsFem are the stress and jacobian material properties (these two are required by the mechanics element) in the following way: Mate.Rank2Materials(\"stress\")=Stress; Mate.Rank4Materials(\"jacobian\")=Jac; where the values of these two tensors are stored in the Material class. Solve the problem Define the mesh We use a square domain here for our calculation, and then the [mesh] block can be given as: [mesh] type=asfem dim=2 xmax=2.0 ymax=2.0 nx=50 ny=50 meshtype=quad4 [end] where a \\(2\\times 2\\) mesh is defined. Gauss point integration (optional) If one wants to use second order mesh, for instance meshtype=quad9 or meshtype=hex27 , then one need to use a higher order gauss points. This can be implemented via: [qpoint] type=gauss order=3[4] [end] Normally, you don't need this block! Define the DoFs The DoFs used in this step are the displacements \\(u_{x}\\) and \\(u_{y}\\) . Then the [dofs] block can be read as: [dofs] name=ux uy [end] Element for the CahnHilliard equation The model presented in Eq. \\(\\eqref{eq:residual}\\) and \\(\\eqref{eq:jacobian}\\) can be applied in the following lines [elmts] [mysolid] type=mechanics dofs=ux uy mate=mymate [end] [end] where type=mechanics option specifies the element we want to use for the linear momentum balance equation. Moreover, we will use the mymate material to calculate the necessary material properties required by this element. Linear elastic material By using the following lines in your [mates] block, the material properties, i.e., ( \\(\\varepsilon\\) ), stress ( \\(\\mathbf{\\sigma}\\) ), and elasticity tensor ( \\(\\mathbb{C}\\) ) can be easily defined: [mates] [mymate] type=linearelastic params=210.0 0.3 // E nu [end] [end] where type=linearelastic specifies linear elastic material we want to use. params= defines the Youngs modulus \\(E=210.0\\) , the poisson ratio \\(\\nu=0.3\\) . Boundary conditions Now, we want to apply a displacement loading condition to the top edge of our rectangle domain and fix the bottom edge at the same time, then, we can use: [bcs] [FixUx] type=dirichlet dofs=ux uy boundary=bottom value=0.0 [end] [loadUx] type=dirichlet dofs=uy value=0.02 boundary=top [end] [end] Static analysis Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=static debug=dep [end] Projection for materials Hold on for a second, if I want to check the stress, strain, and vonMises stress, what should I do? The answer is the [projection] block, which can do the projection from gauss points to the nodal point. For example, if we want to save the strain, stress, and vonMises stress into our result file (vtu), one can do: [projection] scalarmate=vonMises rank2mate=stress strain [end] where scalarmate and rank2mate specify the material name we want to export. Afterwards, they will be displayed in your Paraview . Run it in AsFem Now, let's try your first mechanics example in AsFem. You can create a new text file and name it as step6.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=2.0 ymax=2.0 nx=50 ny=50 meshtype=quad4 [end] [dofs] name=ux uy [end] [elmts] [mysolids] type=mechanics dofs=ux uy mate=mymate [end] [end] [mates] [mymate] type=linearelastic params=210.0 0.3 // E nu [end] [end] [bcs] [FixUx] type=dirichlet dofs=ux uy boundary=bottom value=0.0 [end] [loadUx] type=dirichlet dofs=uy value=0.02 boundary=top [end] [end] [projection] scalarmate=vonMises rank2mate=stress strain [end] [nonlinearsolver] type=nr maxiters=20 r_rel_tol=5.0e-8 r_abs_tol=4.5e-7 solver=mumps [end] [job] type=static debug=dep [end] You can also find the complete input file in examples/tutorial/step6.i . If everything goes well, you can see the following image in your Paraview :","title":"Step-6"},{"location":"Tutorial/step-6/#introduction","text":"In this step, we will try to solve the linear momentum balance equation for the linear elastic problem.","title":"Introduction"},{"location":"Tutorial/step-6/#the-linear-momentum-balance-equation","text":"The equation can be read as follows: $$ \\begin{equation} \\rho\\frac{\\partial v}{\\partial t}=\\mathbf{\\nabla}\\cdot\\mathbf{\\sigma}+\\rho\\mathbf{b} \\label{eq:stress-equation} \\tag{1} \\end{equation} $$ with \\(\\rho\\) being the density, \\(\\mathbf{b}\\) denoting the body force (i.e., gravity), \\(\\mathbf{\\sigma}\\) being the Cauchy stress tensor. The boundary condition for this problem is defined as follows: $$ \\begin{equation} \\mathbf{u}=u_{g}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D}\\qquad\\qquad \\mathbf{\\sigma}\\cdot\\vec{n}=\\mathbf{t}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\end{equation} $$ Next, by using the weighted integration and integration by parts, one can obtain: $$ \\begin{equation} \\delta I[\\mathbf{u}]= \\int_{\\Omega}\\sigma_{ij}\\delta u_{i,j}dV -\\int_{\\Omega}\\rho b_{i}\\delta u_{i}dV -\\int_{\\partial\\Omega}t_{i}\\delta u_{i}dS=0 \\label{eq:weighted-integration} \\tag{2} \\end{equation} $$ then, the residual for \\(\\eqref{eq:weighted-integration}\\) can be expressed as follows: $$ \\begin{equation} R_{u_{i}}^{I}= \\int_{\\Omega}\\sigma_{ij}N_{,j}^{I}dV -\\int_{\\Omega}\\rho b_{i}N^{I}dV -\\int_{\\partial\\Omega_{N}}t_{i}N^{I}dS \\label{eq:residual} \\tag{3} \\end{equation} $$ where the \"acceleration\" term has been ignored. Then the related jacobian matrix can be given as follows: $$ \\begin{equation} K_{ik}^{IJ}=\\frac{\\partial R_{u_{i}}^{I}}{\\partial u_{k}^{J}} =\\int_{\\Omega}\\mathbb{C}_{ijkl} N_{,j}^{I}N_{,l}^{J}dV \\label{eq:jacobian} \\tag{4} \\end{equation} $$ where \\(\\mathbb{C}_{ijkl}\\) denotes the elasticity tensor. \\(I\\) and \\(J\\) respectively represent the I-th and J-th node of the current element.","title":"The linear momentum balance equation"},{"location":"Tutorial/step-6/#constitutive-laws","text":"For the small strain case, one can have $$ \\begin{equation} \\mathbf{\\varepsilon}=\\frac{1}{2}(\\nabla u+\\nabla^{T}u) \\label{eq:strain} \\tag{5} \\end{equation} $$ which can be easily calculated in AsFem as follows: if(elmtinfo.nDim==1){ _GradU.SetFromGradU(elmtsoln.gpGradU[1]); } else if(elmtinfo.nDim==2){ _GradU.SetFromGradU(elmtsoln.gpGradU[1],elmtsoln.gpGradU[2]); } else if(elmtinfo.nDim==3){ _GradU.SetFromGradU(elmtsoln.gpGradU[1],elmtsoln.gpGradU[2],elmtsoln.gpGradU[3]); } Strain=(_GradU+_GradU.Transpose())*0.5; For the linear elasticity tensor \\(\\mathbb{C}\\) , you need to give the Young's modulus and poisson ratio, then its value can be defined as follows: Jacobian.SetFromEandNu(E,nu); where AsFem offers the RankTwoTensor and RankFourTensor class for the complex tensor calculation. Next, once your strain \\(\\mathbf{\\varepsilon}\\) and elasticity tensor \\(\\mathbb{C}\\) are ready, you can easily get your stress tensor \\(\\mathbf{\\sigma}\\) as follows: Stress=Jacobian.DoubleDot(Strain); That's all? Yup, all the calculation is done. If I want to calculate the vonMises stress, what should I do? The answer is quite simple, here is the code RankTwoTensor I; I.SetToIdentity(); devStress=_Stress-_I*(_Stress.Trace()/3.0); Mate.ScalarMaterials(\"vonMises\")=sqrt(1.5*_devStress.DoubleDot(_devStress)); once again, the complex tensor calculation is done by our RankTwoTensor class. So, for a general mechanics problem, what you need to tell AsFem are the stress and jacobian material properties (these two are required by the mechanics element) in the following way: Mate.Rank2Materials(\"stress\")=Stress; Mate.Rank4Materials(\"jacobian\")=Jac; where the values of these two tensors are stored in the Material class.","title":"Constitutive laws"},{"location":"Tutorial/step-6/#solve-the-problem","text":"","title":"Solve the problem"},{"location":"Tutorial/step-6/#define-the-mesh","text":"We use a square domain here for our calculation, and then the [mesh] block can be given as: [mesh] type=asfem dim=2 xmax=2.0 ymax=2.0 nx=50 ny=50 meshtype=quad4 [end] where a \\(2\\times 2\\) mesh is defined.","title":"Define the mesh"},{"location":"Tutorial/step-6/#gauss-point-integration-optional","text":"If one wants to use second order mesh, for instance meshtype=quad9 or meshtype=hex27 , then one need to use a higher order gauss points. This can be implemented via: [qpoint] type=gauss order=3[4] [end] Normally, you don't need this block!","title":"Gauss point integration (optional)"},{"location":"Tutorial/step-6/#define-the-dofs","text":"The DoFs used in this step are the displacements \\(u_{x}\\) and \\(u_{y}\\) . Then the [dofs] block can be read as: [dofs] name=ux uy [end]","title":"Define the DoFs"},{"location":"Tutorial/step-6/#element-for-the-cahnhilliard-equation","text":"The model presented in Eq. \\(\\eqref{eq:residual}\\) and \\(\\eqref{eq:jacobian}\\) can be applied in the following lines [elmts] [mysolid] type=mechanics dofs=ux uy mate=mymate [end] [end] where type=mechanics option specifies the element we want to use for the linear momentum balance equation. Moreover, we will use the mymate material to calculate the necessary material properties required by this element.","title":"Element for the CahnHilliard equation"},{"location":"Tutorial/step-6/#linear-elastic-material","text":"By using the following lines in your [mates] block, the material properties, i.e., ( \\(\\varepsilon\\) ), stress ( \\(\\mathbf{\\sigma}\\) ), and elasticity tensor ( \\(\\mathbb{C}\\) ) can be easily defined: [mates] [mymate] type=linearelastic params=210.0 0.3 // E nu [end] [end] where type=linearelastic specifies linear elastic material we want to use. params= defines the Youngs modulus \\(E=210.0\\) , the poisson ratio \\(\\nu=0.3\\) .","title":"Linear elastic material"},{"location":"Tutorial/step-6/#boundary-conditions","text":"Now, we want to apply a displacement loading condition to the top edge of our rectangle domain and fix the bottom edge at the same time, then, we can use: [bcs] [FixUx] type=dirichlet dofs=ux uy boundary=bottom value=0.0 [end] [loadUx] type=dirichlet dofs=uy value=0.02 boundary=top [end] [end]","title":"Boundary conditions"},{"location":"Tutorial/step-6/#static-analysis","text":"Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=static debug=dep [end]","title":"Static analysis"},{"location":"Tutorial/step-6/#projection-for-materials","text":"Hold on for a second, if I want to check the stress, strain, and vonMises stress, what should I do? The answer is the [projection] block, which can do the projection from gauss points to the nodal point. For example, if we want to save the strain, stress, and vonMises stress into our result file (vtu), one can do: [projection] scalarmate=vonMises rank2mate=stress strain [end] where scalarmate and rank2mate specify the material name we want to export. Afterwards, they will be displayed in your Paraview .","title":"Projection for materials"},{"location":"Tutorial/step-6/#run-it-in-asfem","text":"Now, let's try your first mechanics example in AsFem. You can create a new text file and name it as step6.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=2.0 ymax=2.0 nx=50 ny=50 meshtype=quad4 [end] [dofs] name=ux uy [end] [elmts] [mysolids] type=mechanics dofs=ux uy mate=mymate [end] [end] [mates] [mymate] type=linearelastic params=210.0 0.3 // E nu [end] [end] [bcs] [FixUx] type=dirichlet dofs=ux uy boundary=bottom value=0.0 [end] [loadUx] type=dirichlet dofs=uy value=0.02 boundary=top [end] [end] [projection] scalarmate=vonMises rank2mate=stress strain [end] [nonlinearsolver] type=nr maxiters=20 r_rel_tol=5.0e-8 r_abs_tol=4.5e-7 solver=mumps [end] [job] type=static debug=dep [end] You can also find the complete input file in examples/tutorial/step6.i . If everything goes well, you can see the following image in your Paraview :","title":"Run it in AsFem"},{"location":"Tutorial/step-7/","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat"],"text":"Introduction In this step, we will try to write our first user-defined-material (UMAT). The equation we used here is still the linear momentum balance equation for the linear elastic problem. For more details, one is referred to step-6 . The user-defined-material (umat) In this step, we try to define a coordinate-dependent Young's modulus for our simulation, which can be read as follows: $$ \\begin{equation} E=E_{0}(1+\\delta\\cos(xy)) \\label{eq:E} \\tag{1} \\end{equation} $$ with \\(E_{0}\\) being the constant Youngs modulus, \\(\\delta\\) representing fluctuation. \\(x\\) and \\(y\\) are the coordinate. Write code for your umat-1 AsFem offers several umat(1~10), which means you can easily write your code by editing the cpp file in the src/MateSystem folder. In this case, we will use umat1 , then one can open the User1Material.cpp file with whichever text/code editor he/she likes. Constitutive laws For the small strain case, one can have $$ \\begin{equation} \\mathbf{\\varepsilon}=\\frac{1}{2}(\\nabla u+\\nabla^{T}u). \\label{eq:strain} \\tag{2} \\end{equation} $$ For the 2D case, one can have: GradU.SetFromGradU(elmtsoln.gpGradU[1],elmtsoln.gpGradU[2]); Strain=(GradU+GradU.Transpose())*0.5; The InputParams variable can access the parameters we provide in our input file as follows: E0=InputParams[1-1]; nu=InputParams[2-1]; delta=InputParams[3-1]; then we can write out the following code for the Young's modulus list in Eq. \\(\\eqref{eq:E}\\) as follows: x=elmtinfo.gpCoords(1); y=elmtinfo.gpCoords(2); E=E0*(1+delta*sin(x*y)); From elmtinfo , you can get all the information of the local element. Then we can set up the stress \\(\\mathbf{\\sigma}\\) and elasticity tensor \\(\\mathbb{C}\\) as follows: Jacobian.SetFromEandNu(E,nu); Stress=Jacobian.DoubleDot(Strain) That's all? Yup, that's all for your first UMAT. Solve the problem Choose the umat-1 Since you have wrote the code for your own material, then you should save the User1Material.cpp file and make AsFem again by running(you should have the Makefile , otherwise, please do cmake CMakeLists.txt ): make -j4 Then, you can tell AsFem to use the User1Material via: [mates] [mymate1] type=user1 params=210.0 0.3 0.2 // E0 nu delta [end] [end] here type=user1 means we will use the material model defined in User1Material.cpp . InputParams will store the params you give in the material block. Projection for materials If I want to check the value of the coordinate-dependent Youngs modulus, what should I do? That's easy, you can define a scalar material as follows: Mate.ScalarMaterials(\"MyE\")=E; then in your [projection] block, you can use: [projection] scalarmate=MyE vonMises [end] Then you will see your \"MyE\" in the Paraview . Run it in AsFem Now, let's try your first umat example in AsFem. You can create a new text file and name it as step7.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=10.0 ymax=10.0 nx=100 ny=100 meshtype=quad9 [end] [qpoint] type=gauss order=4 [end] [dofs] name=ux uy [end] [elmts] [mysolids] type=mechanics dofs=ux uy mate=mymate1 [end] [end] [mates] [mymate1] type=user1 params=210.0 0.3 0.2 // E0 nu delta [end] [end] [projection] scalarmate=MyE vonMises [end] [bcs] [fix] type=dirichlet dofs=ux uy value=0.0 boundary=bottom [end] [load] type=dirichlet dofs=uy value=0.02 boundary=top [end] [end] [job] type=static debug=dep [end] You can also find the complete input file in examples/tutorial/step7.i . If everything goes well, you can see the following image in your Paraview :","title":"Step-7"},{"location":"Tutorial/step-7/#introduction","text":"In this step, we will try to write our first user-defined-material (UMAT). The equation we used here is still the linear momentum balance equation for the linear elastic problem. For more details, one is referred to step-6 .","title":"Introduction"},{"location":"Tutorial/step-7/#the-user-defined-material-umat","text":"In this step, we try to define a coordinate-dependent Young's modulus for our simulation, which can be read as follows: $$ \\begin{equation} E=E_{0}(1+\\delta\\cos(xy)) \\label{eq:E} \\tag{1} \\end{equation} $$ with \\(E_{0}\\) being the constant Youngs modulus, \\(\\delta\\) representing fluctuation. \\(x\\) and \\(y\\) are the coordinate.","title":"The user-defined-material (umat)"},{"location":"Tutorial/step-7/#write-code-for-your-umat-1","text":"AsFem offers several umat(1~10), which means you can easily write your code by editing the cpp file in the src/MateSystem folder. In this case, we will use umat1 , then one can open the User1Material.cpp file with whichever text/code editor he/she likes.","title":"Write code for your umat-1"},{"location":"Tutorial/step-7/#constitutive-laws","text":"For the small strain case, one can have $$ \\begin{equation} \\mathbf{\\varepsilon}=\\frac{1}{2}(\\nabla u+\\nabla^{T}u). \\label{eq:strain} \\tag{2} \\end{equation} $$ For the 2D case, one can have: GradU.SetFromGradU(elmtsoln.gpGradU[1],elmtsoln.gpGradU[2]); Strain=(GradU+GradU.Transpose())*0.5; The InputParams variable can access the parameters we provide in our input file as follows: E0=InputParams[1-1]; nu=InputParams[2-1]; delta=InputParams[3-1]; then we can write out the following code for the Young's modulus list in Eq. \\(\\eqref{eq:E}\\) as follows: x=elmtinfo.gpCoords(1); y=elmtinfo.gpCoords(2); E=E0*(1+delta*sin(x*y)); From elmtinfo , you can get all the information of the local element. Then we can set up the stress \\(\\mathbf{\\sigma}\\) and elasticity tensor \\(\\mathbb{C}\\) as follows: Jacobian.SetFromEandNu(E,nu); Stress=Jacobian.DoubleDot(Strain) That's all? Yup, that's all for your first UMAT.","title":"Constitutive laws"},{"location":"Tutorial/step-7/#solve-the-problem","text":"","title":"Solve the problem"},{"location":"Tutorial/step-7/#choose-the-umat-1","text":"Since you have wrote the code for your own material, then you should save the User1Material.cpp file and make AsFem again by running(you should have the Makefile , otherwise, please do cmake CMakeLists.txt ): make -j4 Then, you can tell AsFem to use the User1Material via: [mates] [mymate1] type=user1 params=210.0 0.3 0.2 // E0 nu delta [end] [end] here type=user1 means we will use the material model defined in User1Material.cpp . InputParams will store the params you give in the material block.","title":"Choose the umat-1"},{"location":"Tutorial/step-7/#projection-for-materials","text":"If I want to check the value of the coordinate-dependent Youngs modulus, what should I do? That's easy, you can define a scalar material as follows: Mate.ScalarMaterials(\"MyE\")=E; then in your [projection] block, you can use: [projection] scalarmate=MyE vonMises [end] Then you will see your \"MyE\" in the Paraview .","title":"Projection for materials"},{"location":"Tutorial/step-7/#run-it-in-asfem","text":"Now, let's try your first umat example in AsFem. You can create a new text file and name it as step7.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=10.0 ymax=10.0 nx=100 ny=100 meshtype=quad9 [end] [qpoint] type=gauss order=4 [end] [dofs] name=ux uy [end] [elmts] [mysolids] type=mechanics dofs=ux uy mate=mymate1 [end] [end] [mates] [mymate1] type=user1 params=210.0 0.3 0.2 // E0 nu delta [end] [end] [projection] scalarmate=MyE vonMises [end] [bcs] [fix] type=dirichlet dofs=ux uy value=0.0 boundary=bottom [end] [load] type=dirichlet dofs=uy value=0.02 boundary=top [end] [end] [job] type=static debug=dep [end] You can also find the complete input file in examples/tutorial/step7.i . If everything goes well, you can see the following image in your Paraview :","title":"Run it in AsFem"},{"location":"Tutorial/step-8/","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat","uel"],"text":"Introduction In this step, we will try to implement our first user-defined-element (UEL). Now the equation we used here can be whatever you like. Let's take the heat conduct equation as an example. The general heat conduct equation takes the following form: $$ \\begin{equation} \\rho c_{p}\\frac{\\partial T}{\\partial t}=\\nabla(k\\nabla T)+\\dot{q}_{v} \\label{eq:T} \\tag{1} \\end{equation} $$ where \\(\\rho\\) is the density, \\(c_{p}\\) denotes the heat capacity, \\(\\dot{q}\\) is the volumetric heat source, \\(k\\) represents the thermal conductivity coefficient. The related boundary conditions can be list below: $$ \\begin{equation} T=T_{g}~\\mathrm{on}~\\Omega_{D},\\qquad\\mathrm{with}~-k\\nabla T\\cdot\\vec{n}=j_{0}~\\mathrm{on}~\\Omega_{N} \\label{eq:bc} \\tag{2} \\end{equation} $$ The user-defined-element (uel) In AsFem, users can define their own model (governing equations) by using the uel . In each uel, user must given the details for the related residual and jacobian calculation. In this step, we try to write out the code for our heat equation. The residual and system jacobian matrix for Eq. \\(\\eqref{eq:T}\\) can be read as follows: \\[ \\begin{equation} \\begin{aligned} R_{T}^{I}&=\\int_{\\Omega}\\rho c_{p}\\dot{T} N^{I}dV +\\int_{\\Omega}k\\nabla T\\nabla N^{I}dV -\\int_{\\Omega}\\dot{q}_{v}N^{I}dV -\\int_{\\partial\\Omega}k \\nabla T\\cdot\\vec{n}N^{I} dS \\\\ &=\\int_{\\Omega}\\rho c_{p}\\dot{T} N^{I}dV +\\int_{\\Omega}k\\nabla T\\nabla N^{I}dV -\\int_{\\Omega}\\dot{q}_{v}N^{I}dV +\\int_{\\partial\\Omega}j_{0}N^{I} dS \\end{aligned} \\label{eq:residual} \\tag{3} \\end{equation} \\] and $$ \\begin{equation} K_{TT}^{IJ}=\\frac{\\partial R_{T}^{I}}{\\partial T^{J}}=\\int_{\\Omega}\\rho c_{p}\\frac{\\partial\\dot{T}}{\\partial T}N^{J}N^{I}dV +\\int_{\\Omega}k\\nabla N^{J}\\nabla N^{I}dV \\label{eq:jacobian} \\tag{4} \\end{equation} $$ Then, the formulation part is done! Writing code for your uel-1 AsFem offers several uel(1~20), which means you can easily write your code by editing the cpp file in the src/ElmtSystem folder. In this case, we will use uel1 , then one can open the User1Elmt.cpp file with whichever text/code editor he/she likes. Material properties It is not necessary to call a material code for the calculation, but it could be very flexible if one combines umat and uel . Therefore, one can use one umat to calculate the material properties required by Eq. \\(\\eqref{eq:residual}\\) and Eq. \\(\\eqref{eq:jacobian}\\) . For example, the built-in thermalmate defines: Mate.ScalarMaterials(\"rho\")=InputParams[0];// density Mate.ScalarMaterials(\"Cp\") =InputParams[1];// heat capacity Mate.ScalarMaterials(\"K\") =InputParams[2];// thermal conductivity Mate.ScalarMaterials(\"Q\") =InputParams[3];// body heat source therefore, you can use User1Mate or UserXMate for the same purpose. Once your materials are ready, we can move on to the next step, your first uel ! UEL For Eq. \\(\\eqref{eq:residual}\\) , namely the residual computation, one can write: localR(1)=_rho*_Cp*soln.gpV[1]*shp.test +_K*(soln.gpGradU[1]*shp.grad_test) -_Q*shp.test; next, the system jacobian (Eq. \\(\\eqref{eq:jacobian}\\) ) can be calculated as follows: localK(1,1)=_rho*_Cp*shp.trial*shp.test*ctan[1] +_K*(shp.grad_trial*shp.grad_test)*ctan[0]; That's all the code for your model, done! Solve the problem Choose the uel-1 Since you have wrote the code for your own element, then you should save the User1Elmt.cpp file and make AsFem again by running(you should have the Makefile , otherwise, please do cmake CMakeLists.txt ): make -j4 Then, you can tell AsFem to use the User1Elmt via: [elmts] [mythermal] type=user1 dofs=T mate=mymate [end] [end] here type=user1 means we will use the heat equation defined in User1Elmt.cpp . The related material properties can be defined as follows: [mates] [mymate] type=user2 params=1.0 1.5 2.0 0.0 // rho Cp K Q [end] [end] Projection for materials If one want to check the gradient of the temperature, one can define a vector material as follows: Mate.VectorMaterials(\"gradT\")=elmtsoln.gpGradU[1]; then in your [projection] block, you can use: [projection] vectormate=gradT [end] Then you will see your gradT in the Paraview . Run it in AsFem Now, let's try your first uel example in AsFem. You can create a new text file and name it as step8.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=10.0 ymax=2.0 nx=100 ny=20 meshtype=quad9 [end] [dofs] name=T [end] [elmts] [mythermal] type=user1 dofs=T mate=mymate [end] [end] [mates] [mymate] type=user2 params=1.0 1.5 2.0 0.0 // rho Cp K Q [end] [end] [bcs] [flux] type=neumann dofs=T value=-0.1 boundary=right [end] [end] [timestepping] type=be dt=1.0e-5 dtmax=1.0e-2 time=1.0e-1 optiters=3 adaptive=true [end] [projection] vectormate=gradT [end] [job] type=transient debug=dep [end] You can also find the complete input file in examples/tutorial/step8.i .","title":"Step-8"},{"location":"Tutorial/step-8/#introduction","text":"In this step, we will try to implement our first user-defined-element (UEL). Now the equation we used here can be whatever you like. Let's take the heat conduct equation as an example. The general heat conduct equation takes the following form: $$ \\begin{equation} \\rho c_{p}\\frac{\\partial T}{\\partial t}=\\nabla(k\\nabla T)+\\dot{q}_{v} \\label{eq:T} \\tag{1} \\end{equation} $$ where \\(\\rho\\) is the density, \\(c_{p}\\) denotes the heat capacity, \\(\\dot{q}\\) is the volumetric heat source, \\(k\\) represents the thermal conductivity coefficient. The related boundary conditions can be list below: $$ \\begin{equation} T=T_{g}~\\mathrm{on}~\\Omega_{D},\\qquad\\mathrm{with}~-k\\nabla T\\cdot\\vec{n}=j_{0}~\\mathrm{on}~\\Omega_{N} \\label{eq:bc} \\tag{2} \\end{equation} $$","title":"Introduction"},{"location":"Tutorial/step-8/#the-user-defined-element-uel","text":"In AsFem, users can define their own model (governing equations) by using the uel . In each uel, user must given the details for the related residual and jacobian calculation. In this step, we try to write out the code for our heat equation. The residual and system jacobian matrix for Eq. \\(\\eqref{eq:T}\\) can be read as follows: \\[ \\begin{equation} \\begin{aligned} R_{T}^{I}&=\\int_{\\Omega}\\rho c_{p}\\dot{T} N^{I}dV +\\int_{\\Omega}k\\nabla T\\nabla N^{I}dV -\\int_{\\Omega}\\dot{q}_{v}N^{I}dV -\\int_{\\partial\\Omega}k \\nabla T\\cdot\\vec{n}N^{I} dS \\\\ &=\\int_{\\Omega}\\rho c_{p}\\dot{T} N^{I}dV +\\int_{\\Omega}k\\nabla T\\nabla N^{I}dV -\\int_{\\Omega}\\dot{q}_{v}N^{I}dV +\\int_{\\partial\\Omega}j_{0}N^{I} dS \\end{aligned} \\label{eq:residual} \\tag{3} \\end{equation} \\] and $$ \\begin{equation} K_{TT}^{IJ}=\\frac{\\partial R_{T}^{I}}{\\partial T^{J}}=\\int_{\\Omega}\\rho c_{p}\\frac{\\partial\\dot{T}}{\\partial T}N^{J}N^{I}dV +\\int_{\\Omega}k\\nabla N^{J}\\nabla N^{I}dV \\label{eq:jacobian} \\tag{4} \\end{equation} $$ Then, the formulation part is done!","title":"The user-defined-element (uel)"},{"location":"Tutorial/step-8/#writing-code-for-your-uel-1","text":"AsFem offers several uel(1~20), which means you can easily write your code by editing the cpp file in the src/ElmtSystem folder. In this case, we will use uel1 , then one can open the User1Elmt.cpp file with whichever text/code editor he/she likes.","title":"Writing code for your uel-1"},{"location":"Tutorial/step-8/#material-properties","text":"It is not necessary to call a material code for the calculation, but it could be very flexible if one combines umat and uel . Therefore, one can use one umat to calculate the material properties required by Eq. \\(\\eqref{eq:residual}\\) and Eq. \\(\\eqref{eq:jacobian}\\) . For example, the built-in thermalmate defines: Mate.ScalarMaterials(\"rho\")=InputParams[0];// density Mate.ScalarMaterials(\"Cp\") =InputParams[1];// heat capacity Mate.ScalarMaterials(\"K\") =InputParams[2];// thermal conductivity Mate.ScalarMaterials(\"Q\") =InputParams[3];// body heat source therefore, you can use User1Mate or UserXMate for the same purpose. Once your materials are ready, we can move on to the next step, your first uel !","title":"Material  properties"},{"location":"Tutorial/step-8/#uel","text":"For Eq. \\(\\eqref{eq:residual}\\) , namely the residual computation, one can write: localR(1)=_rho*_Cp*soln.gpV[1]*shp.test +_K*(soln.gpGradU[1]*shp.grad_test) -_Q*shp.test; next, the system jacobian (Eq. \\(\\eqref{eq:jacobian}\\) ) can be calculated as follows: localK(1,1)=_rho*_Cp*shp.trial*shp.test*ctan[1] +_K*(shp.grad_trial*shp.grad_test)*ctan[0]; That's all the code for your model, done!","title":"UEL"},{"location":"Tutorial/step-8/#solve-the-problem","text":"","title":"Solve the problem"},{"location":"Tutorial/step-8/#choose-the-uel-1","text":"Since you have wrote the code for your own element, then you should save the User1Elmt.cpp file and make AsFem again by running(you should have the Makefile , otherwise, please do cmake CMakeLists.txt ): make -j4 Then, you can tell AsFem to use the User1Elmt via: [elmts] [mythermal] type=user1 dofs=T mate=mymate [end] [end] here type=user1 means we will use the heat equation defined in User1Elmt.cpp . The related material properties can be defined as follows: [mates] [mymate] type=user2 params=1.0 1.5 2.0 0.0 // rho Cp K Q [end] [end]","title":"Choose the uel-1"},{"location":"Tutorial/step-8/#projection-for-materials","text":"If one want to check the gradient of the temperature, one can define a vector material as follows: Mate.VectorMaterials(\"gradT\")=elmtsoln.gpGradU[1]; then in your [projection] block, you can use: [projection] vectormate=gradT [end] Then you will see your gradT in the Paraview .","title":"Projection for materials"},{"location":"Tutorial/step-8/#run-it-in-asfem","text":"Now, let's try your first uel example in AsFem. You can create a new text file and name it as step8.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=10.0 ymax=2.0 nx=100 ny=20 meshtype=quad9 [end] [dofs] name=T [end] [elmts] [mythermal] type=user1 dofs=T mate=mymate [end] [end] [mates] [mymate] type=user2 params=1.0 1.5 2.0 0.0 // rho Cp K Q [end] [end] [bcs] [flux] type=neumann dofs=T value=-0.1 boundary=right [end] [end] [timestepping] type=be dt=1.0e-5 dtmax=1.0e-2 time=1.0e-1 optiters=3 adaptive=true [end] [projection] vectormate=gradT [end] [job] type=transient debug=dep [end] You can also find the complete input file in examples/tutorial/step8.i .","title":"Run it in AsFem"}]}